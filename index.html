<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<!-- iPad/iPhone対応 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Pro Visualizer: Ultimate Edition</title>
<!-- Bootstrap Icons CDN -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');

    :root {
        --color-bg: #0d0d0d;
        --color-panel: #1a1a1a;
        --color-panel-border: #333;
        --color-text: #ffffff;
        --color-green: #00e676;
        --color-red: #ff5252;
        --color-sub: #888;
        --font-main: 'Inter', sans-serif;
    }

    * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

    body {
        background-color: var(--color-bg);
        color: var(--color-text);
        font-family: var(--font-main);
        margin: 0;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
        display: flex;
        flex-direction: column;
        /* 数字のガタつき防止（全体適用） */
        font-variant-numeric: tabular-nums;
    }

    /* --- Overlays --- */
    .overlay-screen {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.95);
        z-index: 9999;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: opacity 0.3s;
        backdrop-filter: blur(5px);
    }

    .modal-box {
        background: var(--color-panel);
        padding: 40px;
        border-radius: 24px;
        text-align: center;
        border: 1px solid var(--color-panel-border);
        box-shadow: 0 20px 60px rgba(0,0,0,0.6);
        width: 90%;
        max-width: 500px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        max-height: 90vh;
        overflow-y: auto;
    }
    
    .modal-box::-webkit-scrollbar { width: 8px; }
    .modal-box::-webkit-scrollbar-track { background: #111; }
    .modal-box::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }

    h2 { margin: 0; font-weight: 900; letter-spacing: -0.5px; }
    p.sub { color: #888; font-size: 14px; margin: 0; }

    /* Upload Specific */
    .file-label {
        display: flex; align-items: center; justify-content: center; gap: 10px;
        padding: 18px 30px;
        background: #222;
        color: var(--color-green);
        border: 2px dashed #444;
        border-radius: 16px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 700;
        transition: all 0.2s;
    }
    .file-label:hover { background: #2a2a2a; border-color: var(--color-green); }
    input[type="file"] { display: none; }

    .action-btn {
        padding: 16px 40px;
        background: var(--color-green);
        color: #000;
        border: none;
        border-radius: 50px;
        font-weight: 900;
        font-size: 18px;
        cursor: pointer;
        display: flex; align-items: center; justify-content: center; gap: 10px;
        transition: transform 0.1s, filter 0.2s;
        width: 100%;
    }
    .action-btn:active { transform: scale(0.98); filter: brightness(0.9); }
    .action-btn.secondary { background: #333; color: #fff; }

    /* --- Settings Screen --- */
    .settings-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 15px;
        text-align: left;
        width: 100%;
    }
    .setting-item {
        background: #222;
        padding: 12px 15px;
        border-radius: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .setting-label { font-weight: 600; font-size: 13px; display: flex; align-items: center; gap: 8px; }
    
    .text-input, .select-input {
        background: #111; border: 1px solid #444;
        color: #fff; padding: 8px 10px; border-radius: 8px;
        width: 100%; font-family: inherit; font-size: 14px;
    }
    .select-input { cursor: pointer; }

    /* Toggle Switch */
    .toggle-switch {
        position: relative; width: 46px; height: 24px;
    }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .slider {
        position: absolute; cursor: pointer;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: #444;
        transition: .3s; border-radius: 30px;
    }
    .slider:before {
        position: absolute; content: "";
        height: 18px; width: 18px;
        left: 3px; bottom: 3px;
        background-color: white;
        transition: .3s; border-radius: 50%;
    }
    input:checked + .slider { background-color: var(--color-green); }
    input:checked + .slider:before { transform: translateX(22px); }

    /* --- Result Overlay --- */
    #result-screen {
        z-index: 2000;
        display: none; 
        flex-direction: column;
        padding: 20px;
    }
    .result-header {
        display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;
    }
    .result-title { 
        font-size: 28px; font-weight: 900; color: #fff; 
        border-left: 6px solid var(--color-green); padding-left: 15px; 
    }
    
    .result-grid {
        flex: 1;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        grid-template-rows: repeat(2, 1fr);
        gap: 20px;
        width: 100%; max-width: 1600px; margin: 0 auto;
        min-height: 0;
    }
    .res-card {
        background: #151515; border: 1px solid #333;
        border-radius: 16px; padding: 20px;
        display: flex; flex-direction: column;
        position: relative;
        overflow: hidden;
    }
    .res-card.full-width { grid-column: 1 / -1; }
    
    .res-head { font-size: 16px; color: #ccc; font-weight: bold; margin-bottom: 15px; display: flex; align-items: center; gap: 10px; }
    .res-canvas-container { 
        flex: 1; position: relative; width: 100%; min-height: 0; 
        cursor: crosshair; touch-action: none;
    }
    .res-canvas { width: 100%; height: 100%; display: block; }
    
    /* Tooltip */
    #tooltip {
        position: absolute;
        background: rgba(0,0,0,0.9);
        border: 1px solid #555;
        padding: 8px 12px;
        border-radius: 8px;
        pointer-events: none;
        display: none;
        font-size: 12px;
        font-family: var(--font-main);
        font-variant-numeric: tabular-nums; /* ツールチップも等幅数字 */
        /* Z-Index higher than result-screen (2000) */
        z-index: 9999;
        box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        white-space: nowrap;
    }
    .tt-date { color: #888; margin-bottom: 4px; font-weight: bold; }
    .tt-row { display: flex; justify-content: space-between; gap: 15px; margin-bottom: 2px; }
    .tt-val { font-weight: 700; color: #fff; }

    /* --- Main UI --- */
    #main-container {
        flex: 1; display: flex; flex-direction: column;
        padding: 10px 20px; position: relative;
    }

    .header { height: 60px; display: flex; justify-content: space-between; align-items: center; z-index: 10; }
    .main-title { 
        font-size: 24px; font-weight: 900; 
        border-left: 5px solid var(--color-green); padding-left: 15px; letter-spacing: -0.5px;
    }
    #date-display { 
        font-size: 36px; font-weight: 900; 
        font-variant-numeric: tabular-nums; 
        text-align: right; letter-spacing: -1px; 
    }

    /* Adjusted chart area for full width */
    #chart-area { position: relative; flex: 2; margin: 10px 10px 0 10px; overflow: hidden; }
    
    #bg-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; opacity: 0.5; }
    #axis-container { position: absolute; top: -25px; left: 0; width: 100%; height: 25px; z-index: 2; }
    .grid-line { position: absolute; top: 0; bottom: -100vh; width: 1px; background: rgba(255,255,255,0.08); z-index: 1; }
    .axis-label { position: absolute; top: -8px; transform: translateX(-50%); font-size: 12px; color: #666; font-weight: 700; }

    #bars-container { position: relative; width: 100%; height: 100%; z-index: 5; padding-right: 120px; /* 右側の文字切れ防止用にパディング確保 */ }
    .bar-row { position: absolute; left: 0; width: 100%; height: 60px; display: flex; align-items: center; will-change: transform; }
    
    .bar-wrapper { flex: 1; height: 100%; position: relative; display: flex; align-items: center; }
    
    .bar {
        height: 42px; 
        border-radius: 6px; 
        position: relative;
        box-shadow: 4px 4px 15px rgba(0,0,0,0.4);
        will-change: width; transition: background-color 0.2s;
        min-width: 0; 
        display: flex; align-items: center;
        justify-content: flex-end; 
        padding-right: 15px; 
        overflow: visible; 
    }

    /* Images */
    .bar-img {
        position: absolute; left: -2px; top: 50%; transform: translateY(-50%);
        width: 36px; height: 36px; border-radius: 50%;
        background: #000; border: 2px solid #fff;
        object-fit: cover; z-index: 5;
        display: none;
    }

    /* Labels */
    .bar-label-in {
        font-weight: 900; font-size: 20px; 
        white-space: nowrap; z-index: 4;
        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        transition: color 0.2s;
    }
    
    /* Pop-out label style */
    .label-popout {
        position: absolute; left: 100%; top: 50%; transform: translateY(-50%);
        margin-left: 10px;
        background: rgba(0,0,0,0.6); padding: 4px 8px; border-radius: 4px;
        color: #fff !important; font-size: 14px;
        display: flex; align-items: center;
        white-space: nowrap;
    }

    .bar-values {
        position: absolute; left: 100%; margin-left: 14px;
        display: flex; flex-direction: column; justify-content: center;
        line-height: 1.1; white-space: nowrap;
    }
    .val-main { 
        font-size: 22px; font-weight: 900; color: #fff; letter-spacing: -0.5px; 
        font-variant-numeric: tabular-nums;
    }
    .val-sub-group { display: flex; gap: 10px; align-items: baseline; }
    .val-sub { 
        font-size: 15px; font-weight: 700; color: var(--color-green); 
        font-variant-numeric: tabular-nums;
    }
    .val-sub.negative { color: var(--color-red); }
    .val-gap { 
        font-size: 15px; font-weight: 700; color: var(--color-sub); 
        font-variant-numeric: tabular-nums;
    }

    /* Bottom Info & Graphs - Adjusted Height */
    .bottom-section {
        flex: none; /* Do not grow */
        height: 220px; /* Moderate size */
        display: flex; gap: 15px;
        background: rgba(255,255,255,0.02);
        border-radius: 12px; 
        /* Align margin with chart-area */
        margin: 10px 10px 0 10px; 
        padding: 10px; 
        border: 1px solid #222;
        position: relative;
    }
    .daily-graph-box { 
        flex: 2.5; 
        position: relative; display: flex; flex-direction: column; 
    }
    .graph-header { 
        font-size: 14px; color: #888; font-weight: bold; margin-bottom: 5px; display: flex; align-items: center; gap: 8px; 
    }
    #daily-canvas { flex: 1; width: 100%; }
    
    .combined-box { 
        flex: 1; 
        display: flex; flex-direction: column; justify-content: center; align-items: flex-end; text-align: right; 
        min-width: 0; /* Flexbox item overflow prevention */
        overflow: hidden;
    }
    .stat-label { 
        font-size: 12px; color: #666; font-weight: 700; letter-spacing: 0.5px; 
    }
    
    .total-group { 
        display: flex; align-items: baseline; gap: 10px; 
        width: 100%; justify-content: flex-end; /* Stability for values */
    }
    .stat-val { 
        /* default font size, handled by JS */
        font-size: 26px; font-weight: 900; color: #fff; letter-spacing: -0.5px;
        font-variant-numeric: tabular-nums;
        white-space: nowrap;
        transition: font-size 0.1s;
    }
    .stat-gain { 
        /* default font size, handled by JS */
        font-size: 18px; font-weight: 700; color: var(--color-green); 
        font-variant-numeric: tabular-nums;
        white-space: nowrap;
        transition: font-size 0.1s;
    }
    .stat-gain.negative { color: var(--color-red); }

    /* --- Controls Bar --- */
    #controls-bar {
        height: 90px;
        background: #0a0a0a;
        display: flex; align-items: center;
        padding: 0 20px; gap: 15px; /* Gapを少し狭める */
        border-top: 1px solid #222;
        z-index: 100;
        box-shadow: 0 -10px 30px rgba(0,0,0,0.5);
    }

    .control-group { display: flex; flex-direction: column; justify-content: center; color: #888; font-size: 11px; font-weight: bold; min-width: 70px; }
    .control-row { display: flex; justify-content: space-between; width: 100%; margin-bottom: 6px; }

    input[type=range] {
        -webkit-appearance: none; background: transparent;
        height: 24px; width: 100%; cursor: pointer; margin: 0;
    }
    input[type=range]:focus { outline: none; }
    input[type=range]::-webkit-slider-runnable-track {
        width: 100%; height: 8px; cursor: pointer;
        background: #333; border-radius: 4px;
        transition: 0.2s;
    }
    input[type=range]::-webkit-slider-thumb {
        height: 20px; width: 20px; border-radius: 50%;
        background: var(--color-green); cursor: pointer;
        -webkit-appearance: none;
        margin-top: -6px; 
        box-shadow: 0 0 10px rgba(0,230,118,0.5);
        transition: transform 0.1s;
    }
    input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); }
    input[type=range]:active::-webkit-slider-thumb { transform: scale(1.1); background: #fff; }

    /* 重なり防止のために幅を縮小 */
    #seek-slider { width: 140px; }
    #speed-slider { width: 100px; }

    .icon-btn {
        background: #222; color: #fff;
        border: 1px solid #333; padding: 0 12px;
        height: 40px;
        border-radius: 8px; font-size: 13px; font-weight: 700;
        cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;
        transition: 0.2s;
    }
    .icon-btn:hover { background: #333; border-color: #555; }
    .icon-btn.active { background: var(--color-green); color: #000; border-color: var(--color-green); }

    #play-pause-btn {
        width: 60px; height: 60px; border-radius: 50%;
        font-size: 32px; background: #222; color: var(--color-green);
        border: 2px solid #333; margin-right: 5px;
        padding: 0; display: flex; align-items: center; justify-content: center;
        transition: all 0.2s;
        flex-shrink: 0;
    }
    #play-pause-btn:hover { background: #2a2a2a; border-color: var(--color-green); transform: scale(1.05); }
    #play-pause-btn:active { transform: scale(0.95); }
    
    .file-btn-group { display: flex; gap: 8px; }

    .separator { width: 1px; height: 40px; background: #333; }

</style>
</head>
<body>

    <!-- Tooltip -->
    <div id="tooltip"></div>

    <!-- Upload Screen -->
    <div id="upload-screen" class="overlay-screen">
        <div class="modal-box">
            <div>
                <h2>Pro Visualizer</h2>
                <p class="sub">Ultimate Edition</p>
            </div>
            
            <label for="file-input" class="file-label">
                <i class="bi bi-folder2-open" style="font-size:20px;"></i> Select CSV File
            </label>
            <input type="file" id="file-input" accept=".csv, text/csv, text/plain, */*">
            
            <div id="file-name" style="color:#fff; font-size:14px; font-weight:bold; min-height:20px;"></div>
            
            <button id="to-settings-btn" class="action-btn" style="display:none;">
                Next <i class="bi bi-arrow-right-circle-fill"></i>
            </button>
        </div>
    </div>

    <!-- Settings Screen -->
    <div id="settings-screen" class="overlay-screen" style="display:none;">
        <div class="modal-box">
            <h2><i class="bi bi-gear-fill"></i> Configuration</h2>
            
            <div class="settings-grid">
                <!-- Title -->
                <div class="setting-item" style="flex-direction:column; align-items:flex-start; gap:10px;">
                    <span class="setting-label"><i class="bi bi-type-h1"></i> Graph Title</span>
                    <input type="text" id="config-title" class="text-input" value="Subscriber Race">
                </div>
                
                <!-- Bottom Graph Label -->
                <div class="setting-item" style="flex-direction:column; align-items:flex-start; gap:10px;">
                    <span class="setting-label"><i class="bi bi-tag"></i> Bottom Graph Label</span>
                    <input type="text" id="config-bottom-title" class="text-input" value="Daily Gain">
                </div>
                
                <!-- Gap Target Selection -->
                <div class="setting-item" style="flex-direction:column; align-items:flex-start; gap:10px;">
                    <span class="setting-label"><i class="bi bi-crosshair"></i> Initial Gap Target</span>
                    <select id="config-gap-target" class="select-input">
                        <option value="Leader">Leader (Auto)</option>
                    </select>
                </div>

                <!-- Total Value Label -->
                <div class="setting-item" style="flex-direction:column; align-items:flex-start; gap:10px;">
                    <span class="setting-label"><i class="bi bi-tag"></i> Total Value Label</span>
                    <input type="text" id="config-total-label" class="text-input" value="Combined Total">
                </div>

                <!-- History Window -->
                <div class="setting-item" style="flex-direction:column; align-items:flex-start; gap:10px;">
                    <span class="setting-label"><i class="bi bi-hourglass-split"></i> History Window (Days)</span>
                    <div style="display:flex; width:100%; gap:10px; align-items:center;">
                        <input type="range" id="config-history-slider" min="1" max="1000" value="100" style="flex:1;">
                        <input type="number" id="config-history-input" value="100" min="1" step="1" style="width:70px; text-align:right;" class="text-input">
                    </div>
                </div>

                <!-- Duration Setting -->
                <div class="setting-item" style="flex-direction:column; align-items:flex-start; gap:10px;">
                    <span class="setting-label"><i class="bi bi-stopwatch"></i> Race Duration</span>
                    <div style="display:flex; width:100%; gap:10px; align-items:center;">
                        <input type="range" id="config-duration-slider" min="60" max="600" step="10" value="300" style="flex:1;">
                        <div style="display:flex; align-items:center; gap:5px;">
                            <input type="number" id="config-duration-input" value="300" style="width:70px; text-align:right;" class="text-input">
                            <span style="font-size:12px; color:#888;">sec</span>
                        </div>
                    </div>
                </div>

                <!-- Switches -->
                <div class="setting-item">
                    <span class="setting-label"><i class="bi bi-image"></i> Show Icons (if in CSV)</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="config-icons" checked>
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="setting-item">
                    <span class="setting-label"><i class="bi bi-distribute-vertical"></i> Enable Gap Mode Switch</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="config-gap-btn" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="setting-item">
                    <span class="setting-label"><i class="bi bi-clipboard-data"></i> Show Result Screen</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="config-result" checked>
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="setting-item">
                    <span class="setting-label"><i class="bi bi-graph-up"></i> Show Bottom Graph</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="config-bottom-graph" checked>
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="setting-item">
                    <span class="setting-label"><i class="bi bi-bar-chart-steps"></i> Show Background Graph</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="config-bg-graph" checked>
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="setting-item">
                    <span class="setting-label"><i class="bi bi-calculator"></i> Show Combined Total</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="config-total" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

            <button id="start-btn" class="action-btn">
                <i class="bi bi-play-circle-fill"></i> Start Visualization
            </button>
        </div>
    </div>

    <!-- Result Screen -->
    <div id="result-screen" class="overlay-screen">
        <div style="width:100%; max-width:1600px; display:flex; flex-direction:column; height:90%;">
            <div class="result-header">
                <div style="display:flex; align-items:center;">
                    <div class="result-title">Result Summary</div>
                </div>
                <div style="display:flex; align-items:center; gap:10px;">
                    <button id="change-file-result-btn" class="icon-btn">
                        <i class="bi bi-folder2-open"></i> Open
                    </button>
                    <button id="replay-btn" class="action-btn secondary" style="width:auto;">
                        <i class="bi bi-arrow-counterclockwise"></i> Replay
                    </button>
                </div>
            </div>
            <div class="result-grid">
                <!-- Full Width: Total -->
                <div class="res-card full-width">
                    <div class="res-head"><i class="bi bi-bar-chart-line-fill"></i> All Time Total</div>
                    <div class="res-canvas-container" id="con-total">
                        <canvas id="res-canvas-total" class="res-canvas"></canvas>
                    </div>
                </div>
                <!-- Half: Daily Gain -->
                <div class="res-card">
                    <div class="res-head"><i class="bi bi-graph-up-arrow"></i> Daily Gain History</div>
                    <div class="res-canvas-container" id="con-gain">
                        <canvas id="res-canvas-gain" class="res-canvas"></canvas>
                    </div>
                </div>
                <!-- Half: Gap -->
                <div class="res-card">
                    <div class="res-head"><i class="bi bi-distribute-vertical"></i> Gap to Target (Hidden 0-line)</div>
                    <div class="res-canvas-container" id="con-gap">
                        <canvas id="res-canvas-gap" class="res-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div id="main-container">
        <div class="header">
            <div class="main-title" id="disp-title">Subscriber Race</div>
            <div id="date-display">--</div>
        </div>

        <div id="chart-area">
            <!-- Background Graph -->
            <canvas id="bg-canvas"></canvas>
            <!-- Axis & Bars -->
            <div id="axis-container"></div>
            <div id="bars-container"></div>
        </div>

        <div class="bottom-section" id="bottom-section">
            <div class="daily-graph-box" id="daily-graph-box">
                <div class="graph-header">
                    <span id="bottom-graph-title"><i class="bi bi-graph-up"></i> Daily Gain</span>
                </div>
                <canvas id="daily-canvas"></canvas>
            </div>
            <div class="combined-box" id="combined-box">
                <div class="stat-label" id="stat-label-el">Combined Total</div>
                <div class="total-group">
                    <div class="stat-val" id="combined-display">0</div>
                    <div class="stat-gain" id="combined-gain"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="controls-bar">
        <div class="file-btn-group">
            <button id="change-file-btn" class="icon-btn" title="Open New File"><i class="bi bi-folder2-open"></i></button>
            <button id="open-settings-btn" class="icon-btn" title="Settings"><i class="bi bi-gear-fill"></i></button>
            <button id="restart-btn" class="icon-btn" title="Restart"><i class="bi bi-skip-start-fill"></i></button>
        </div>
        
        <button id="play-pause-btn"><i class="bi bi-play-fill"></i></button>
        
        <div class="control-group" style="flex:1;">
            <div class="control-row">
                <span>SEEK</span>
                <span id="seek-val">0%</span>
            </div>
            <input type="range" id="seek-slider" min="0" max="100" step="0.01" value="0">
        </div>
        
        <div class="separator"></div>

        <div class="control-group">
            <div class="control-row">
                <span>SPEED</span>
                <span id="speed-display">1.0x</span>
            </div>
            <input type="range" id="speed-slider" min="0" max="100" step="0.1" value="50">
        </div>

        <div class="separator"></div>
        
        <!-- Dynamic Target Select -->
        <div class="control-group" style="min-width: 100px;">
             <div class="control-row"><span>TARGET</span></div>
             <select id="dynamic-gap-target" class="select-input" style="height:30px; padding:0 5px; font-size:12px;">
                 <option value="Leader">Leader</option>
             </select>
        </div>

        <div class="control-group" style="min-width:110px;">
            <div class="control-row"><span>MODE</span></div>
            <button id="mode-btn" class="icon-btn" style="width:100%;">
                <i class="bi bi-list-ol"></i> Total Mode
            </button>
        </div>
    </div>

<script>
    // --- Configuration & Constants ---
    let TOTAL_DURATION_BASE = 300000; 
    let HISTORY_WINDOW = 100; 
    
    // スムージング係数を微調整 (0.1) - アニメーションが先行しすぎないように遅らせる
    const SCALE_SMOOTHING = 0.1; 

    // User Config
    const config = {
        title: "Subscriber Race",
        bottomTitle: "Daily Gain",
        totalLabel: "Combined Total",
        gapTarget: "Leader", // Leader or specific item name
        enableGapSwitch: true,
        showResult: true,
        showBottomGraph: true,
        showBgGraph: true,
        showTotal: true,
        showIcons: true
    };

    // DOM Elements
    const fileInput = document.getElementById('file-input');
    const toSettingsBtn = document.getElementById('to-settings-btn');
    const startBtn = document.getElementById('start-btn');
    const uploadScreen = document.getElementById('upload-screen');
    const settingsScreen = document.getElementById('settings-screen');
    const resultScreen = document.getElementById('result-screen');
    const fileNameDisplay = document.getElementById('file-name');
    const dispTitle = document.getElementById('disp-title');
    const tooltip = document.getElementById('tooltip');
    
    const changeFileBtn = document.getElementById('change-file-btn');
    const changeFileResBtn = document.getElementById('change-file-result-btn');
    const openSettingsBtn = document.getElementById('open-settings-btn');
    const restartBtn = document.getElementById('restart-btn');

    const confTitle = document.getElementById('config-title');
    const confBottomTitle = document.getElementById('config-bottom-title');
    const confGapTarget = document.getElementById('config-gap-target');
    const dynamicGapTarget = document.getElementById('dynamic-gap-target');
    const confTotalLabel = document.getElementById('config-total-label');
    const confGapBtn = document.getElementById('config-gap-btn');
    const confResult = document.getElementById('config-result');
    const confBottom = document.getElementById('config-bottom-graph');
    const confBg = document.getElementById('config-bg-graph');
    const confTotal = document.getElementById('config-total');
    const confIcons = document.getElementById('config-icons');
    
    // Duration & History Inputs
    const confDurSlider = document.getElementById('config-duration-slider');
    const confDurInput = document.getElementById('config-duration-input');
    const confHistSlider = document.getElementById('config-history-slider');
    const confHistInput = document.getElementById('config-history-input');

    const barsContainer = document.getElementById('bars-container');
    const axisContainer = document.getElementById('axis-container');
    const dateDisplay = document.getElementById('date-display');
    const combinedDisplay = document.getElementById('combined-display');
    const combinedGain = document.getElementById('combined-gain');
    const bottomGraphTitle = document.getElementById('bottom-graph-title');
    const statLabelEl = document.getElementById('stat-label-el');
    const combinedBox = document.getElementById('combined-box');
    const dailyGraphBox = document.getElementById('daily-graph-box');
    
    const bgCanvas = document.getElementById('bg-canvas');
    const dailyCanvas = document.getElementById('daily-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    const dailyCtx = dailyCanvas.getContext('2d');

    const resCanvasTotal = document.getElementById('res-canvas-total');
    const resCanvasGain = document.getElementById('res-canvas-gain');
    const resCanvasGap = document.getElementById('res-canvas-gap');
    const replayBtn = document.getElementById('replay-btn');

    const seekSlider = document.getElementById('seek-slider');
    const seekVal = document.getElementById('seek-val');
    const speedSlider = document.getElementById('speed-slider');
    const speedDisplay = document.getElementById('speed-display');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const modeBtn = document.getElementById('mode-btn');

    // State
    let processedData = [];
    let itemsList = [];
    let colors = {};
    let itemImages = {};
    
    let isPlaying = false;
    let animationTime = 0;
    let lastFrameTime = 0;
    let playbackSpeed = 1;
    let barElements = {}; 
    let isGapMode = false;
    let animationFrameId = null;

    // Smooth Scale State objects
    const bgScale = { min: 0, max: 100 };
    const bottomScale = { min: 0, max: 100 };

    // Result Chart Instances
    let chartTotal, chartGain, chartGap;

    // --- Utils ---
    function getContrastYIQ(hexcolor){
        if(!hexcolor) return 'black';
        hexcolor = hexcolor.replace("#", "");
        if(hexcolor.length === 3) hexcolor = hexcolor.split('').map(c=>c+c).join('');
        var r = parseInt(hexcolor.substr(0,2),16);
        var g = parseInt(hexcolor.substr(2,2),16);
        var b = parseInt(hexcolor.substr(4,2),16);
        var yiq = ((r*299)+(g*587)+(b*114))/1000;
        return (yiq >= 128) ? 'black' : 'white';
    }

    // --- File Handling ---
    function openFileSelector() {
        fileInput.value = null;
        fileInput.click();
    }

    changeFileBtn.addEventListener('click', openFileSelector);
    changeFileResBtn.addEventListener('click', openFileSelector);

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;
        
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        isPlaying = false;
        playPauseBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
        
        const reader = new FileReader();
        reader.onload = (ev) => {
            if(parseCSV(ev.target.result)) {
                if(uploadScreen.style.display !== 'none') {
                    fileNameDisplay.textContent = file.name;
                    toSettingsBtn.style.display = 'inline-flex';
                } else {
                    resultScreen.style.display = 'none';
                    settingsScreen.style.display = 'flex';
                    settingsScreen.style.opacity = 1;
                }
                updateGapTargetOptions();
            } else {
                alert("CSV Error: Check format.");
            }
        };
        reader.readAsText(file);
    });

    toSettingsBtn.addEventListener('click', () => {
        uploadScreen.style.opacity = 0;
        setTimeout(() => {
            uploadScreen.style.display = 'none';
            settingsScreen.style.display = 'flex';
        }, 300);
    });

    function updateGapTargetOptions() {
        // 設定画面のプルダウン更新
        confGapTarget.innerHTML = '<option value="Leader">Leader (Auto)</option>';
        itemsList.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item;
            opt.textContent = item;
            confGapTarget.appendChild(opt);
        });

        // プレイ画面の動的プルダウン更新
        dynamicGapTarget.innerHTML = '<option value="Leader">Leader (Auto)</option>';
        itemsList.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item;
            opt.textContent = item;
            dynamicGapTarget.appendChild(opt);
        });

        // 現在の値を選択
        dynamicGapTarget.value = config.gapTarget;
    }

    // --- Dynamic Target Change ---
    confGapTarget.addEventListener('change', () => {
        config.gapTarget = confGapTarget.value;
        dynamicGapTarget.value = confGapTarget.value;
    });

    dynamicGapTarget.addEventListener('change', () => {
        config.gapTarget = dynamicGapTarget.value;
        confGapTarget.value = dynamicGapTarget.value; // 設定画面の方も同期
        renderFrame(); // 即座に反映
    });

    // --- Settings & Restart Control ---
    openSettingsBtn.addEventListener('click', () => {
        // 一時停止して設定画面を開く
        isPlaying = false;
        playPauseBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
        settingsScreen.style.display = 'flex';
        setTimeout(() => settingsScreen.style.opacity = 1, 10);
        // 設定画面を開くときにリストが空でないか確認して再構築
        if(itemsList.length > 0) {
            updateGapTargetOptions();
            confGapTarget.value = config.gapTarget;
        }
    });

    restartBtn.addEventListener('click', () => {
        // リスタート
        animationTime = 0;
        isPlaying = true;
        playPauseBtn.innerHTML = '<i class="bi bi-pause-fill"></i>';
        lastFrameTime = performance.now();
        seekSlider.value = 0;
        seekVal.textContent = "0%";
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = requestAnimationFrame(gameLoop);
    });

    // Inputs Sync
    confDurSlider.addEventListener('input', () => { confDurInput.value = confDurSlider.value; });
    confDurInput.addEventListener('change', () => { 
        let val = parseInt(confDurInput.value);
        if(val < 1) val = 1;
        confDurInput.value = val;
        if(val >= 60 && val <= 600) confDurSlider.value = val;
    });

    confHistSlider.addEventListener('input', () => { confHistInput.value = confHistSlider.value; });
    confHistInput.addEventListener('change', () => {
        let val = parseInt(confHistInput.value);
        if(val < 1) val = 1;
        confHistInput.value = val;
        if(val <= 1000) confHistSlider.value = val;
    });

    startBtn.addEventListener('click', () => {
        config.title = confTitle.value || "Subscriber Race";
        config.bottomTitle = confBottomTitle.value || "Daily Gain";
        config.totalLabel = confTotalLabel.value || "Combined Total";
        config.gapTarget = confGapTarget.value;
        config.enableGapSwitch = confGapBtn.checked;
        config.showResult = confResult.checked;
        config.showBottomGraph = confBottom.checked;
        config.showBgGraph = confBg.checked;
        config.showTotal = confTotal.checked;
        config.showIcons = confIcons.checked;

        // Sync dynamic select
        dynamicGapTarget.value = config.gapTarget;

        const durVal = parseInt(confDurInput.value);
        if(durVal && durVal > 0) TOTAL_DURATION_BASE = durVal * 1000;

        const histVal = parseInt(confHistInput.value);
        if(histVal && histVal > 0) HISTORY_WINDOW = histVal;

        dispTitle.textContent = config.title;
        bottomGraphTitle.innerHTML = `<i class="bi bi-graph-up"></i> ${config.bottomTitle}`;
        statLabelEl.textContent = config.totalLabel;
        
        modeBtn.style.display = config.enableGapSwitch ? 'flex' : 'none';
        dailyGraphBox.style.visibility = config.showBottomGraph ? 'visible' : 'hidden';
        bgCanvas.style.display = config.showBgGraph ? 'block' : 'none';
        combinedBox.style.visibility = config.showTotal ? 'visible' : 'hidden';

        settingsScreen.style.opacity = 0;
        setTimeout(() => settingsScreen.style.display = 'none', 300);

        resizeAllCanvases();
        createDOMBars();
        
        // Start from beginning when clicking Start from settings
        animationTime = 0;
        seekSlider.value = 0;
        seekVal.textContent = "0%";
        
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        isPlaying = true;
        lastFrameTime = performance.now();
        playPauseBtn.innerHTML = '<i class="bi bi-pause-fill"></i>';
        
        animationFrameId = requestAnimationFrame(gameLoop);
    });

    // --- Speed Logic ---
    function getSpeedFromSlider(val) {
        if(val <= 50) {
            const t = val;
            return 0.001 * Math.pow(1000, t/50);
        } else {
            const t = val - 50;
            return 1 * Math.pow(100, t/50);
        }
    }

    speedSlider.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        playbackSpeed = getSpeedFromSlider(val);
        let label = "";
        if(playbackSpeed < 0.01) label = playbackSpeed.toFixed(4) + "x";
        else if(playbackSpeed < 1) label = playbackSpeed.toFixed(2) + "x";
        else label = playbackSpeed.toFixed(1) + "x";
        speedDisplay.textContent = label;
    });

    // --- Main Loop ---
    function gameLoop(now) {
        if(!isPlaying) return;
        const dt = now - lastFrameTime;
        lastFrameTime = now;

        animationTime += dt * playbackSpeed;
        if(animationTime >= TOTAL_DURATION_BASE) {
            animationTime = TOTAL_DURATION_BASE;
            isPlaying = false;
            playPauseBtn.innerHTML = '<i class="bi bi-arrow-counterclockwise"></i>';
            renderFrame(); 
            if(config.showResult) showResultScreen();
            return;
        }

        const pct = (animationTime / TOTAL_DURATION_BASE) * 100;
        seekSlider.value = pct;
        seekVal.textContent = Math.floor(pct) + "%";
        
        renderFrame();
        if(isPlaying) animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- Text Resizing Logic ---
    function updateScaledText(element, num, isGain) {
        let str = "";
        if (isGain) {
            str = (num >= 0 ? '+' : '') + Math.floor(num).toLocaleString();
        } else {
            str = Math.floor(num).toLocaleString();
        }
        
        element.textContent = str;
        
        const len = str.length;
        if (isGain) {
            if (len > 12) element.style.fontSize = '12px';
            else if (len > 9) element.style.fontSize = '14px';
            else if (len > 7) element.style.fontSize = '16px';
            else element.style.fontSize = '18px';
        } else {
            if (len > 12) element.style.fontSize = '16px';
            else if (len > 10) element.style.fontSize = '20px';
            else if (len > 8) element.style.fontSize = '22px';
            else element.style.fontSize = '26px';
        }
    }

    // --- Render Frame ---
    function renderFrame() {
        const progress = animationTime / TOTAL_DURATION_BASE;
        const totalLen = processedData.length - 1;
        const currentFloatIdx = progress * totalLen;
        const idxLow = Math.floor(currentFloatIdx);
        const idxHigh = Math.min(idxLow + 1, totalLen);
        const ratio = currentFloatIdx - idxLow;

        const dLow = processedData[idxLow];
        const dHigh = processedData[idxHigh];

        let items = [];
        let totalVal = 0;
        
        const getVal = (name) => lerp(dLow.values[name], dHigh.values[name], ratio);

        itemsList.forEach(name => {
            const val = getVal(name);
            const df1 = dLow.diffs[name];
            const df2 = dHigh.diffs[name];
            const diff = lerp(df1, df2, ratio);
            items.push({ name, val, diff });
            totalVal += val;
        });

        // Sort by Value for Bar Race
        items.sort((a,b) => b.val - a.val);
        const maxVal = items[0].val; 
        
        // Determine Target Value for Gap
        let gapTargetVal = 0;
        if (config.gapTarget === 'Leader') {
            gapTargetVal = items[0].val; // Current Leader Value
        } else {
            gapTargetVal = getVal(config.gapTarget);
        }

        // Update Bars
        items.forEach((item, rank) => {
            const el = barElements[item.name];
            el.row.style.transform = `translateY(${rank * 70}px)`;
            
            const barPct = (item.val / (maxVal * 1.25)) * 100;
            el.bar.style.width = barPct + '%';
            
            el.mVal.textContent = Math.floor(item.val).toLocaleString();
            const gain = Math.floor(item.diff);
            const gainStr = (gain >= 0 ? '+' : '') + gain.toLocaleString();
            el.sVal.textContent = gainStr;
            el.sVal.className = 'val-sub' + (gain < 0 ? ' negative' : '');

            // Label
            const name = item.name;
            const contrastColor = getContrastYIQ(colors[name]);
            const labelWidth = name.length * 12 + 50; 
            const barWidthPx = (barsContainer.clientWidth * barPct) / 100;

            if(barWidthPx < labelWidth) {
                el.labelIn.textContent = "";
                el.labelOut.textContent = name;
                el.labelOut.style.display = "flex";
            } else {
                el.labelIn.textContent = name;
                el.labelIn.style.color = contrastColor;
                el.labelOut.style.display = "none";
            }

            if(isGapMode) {
                let gap = gapTargetVal - item.val;
                
                // Gap logic display
                // If it is effectively 0 (the target/leader)
                if (Math.abs(gap) < 0.1) {
                    if (config.gapTarget === 'Leader') {
                        el.gVal.innerHTML = '<i class="bi bi-trophy-fill"></i> Leader';
                        el.gVal.style.color = 'var(--color-green)';
                    } else {
                        el.gVal.innerHTML = '<i class="bi bi-crosshair"></i> Target';
                        el.gVal.style.color = 'var(--color-green)';
                    }
                } else {
                    el.gVal.textContent = `(Gap: ${Math.floor(gap).toLocaleString()})`;
                    el.gVal.style.color = 'var(--color-sub)';
                }
                el.gVal.style.display = 'inline';
            } else {
                el.gVal.style.display = 'none';
            }
        });

        // Global Stats
        renderAxisNice(maxVal * 1.25);
        const dObj = new Date(lerp(dLow.date.getTime(), dHigh.date.getTime(), ratio));
        dateDisplay.textContent = formatDate(dObj);
        
        let totalGain = 0;
        items.forEach(i => totalGain += i.diff);
        
        updateScaledText(combinedDisplay, totalVal, false);
        updateScaledText(combinedGain, totalGain, true);
        combinedGain.className = 'stat-gain' + (totalGain < 0 ? ' negative' : '');

        if(config.showBgGraph) {
            renderGraph({
                ctx: bgCtx, canvas: bgCanvas, data: processedData, items: itemsList,
                currentIdx: currentFloatIdx, windowSize: HISTORY_WINDOW,
                mode: 'Total', scaleState: bgScale, lineWidth: 4, opacity: 0.6
            });
        }

        if(config.showBottomGraph) {
            renderGraph({
                ctx: dailyCtx, canvas: dailyCanvas, data: processedData, items: itemsList,
                currentIdx: currentFloatIdx, windowSize: HISTORY_WINDOW,
                mode: isGapMode ? 'Gap' : 'Diff', scaleState: bottomScale, lineWidth: 3, opacity: 1.0,
                drawXAxis: true
            });
        }
    }

    // --- Dynamic Graph Renderer ---
    function renderGraph({ctx, canvas, data, items, currentIdx, windowSize, mode, scaleState, lineWidth, opacity, drawXAxis}) {
        const w = canvas.logicalWidth;
        const h = canvas.logicalHeight;
        ctx.clearRect(0, 0, w, h);
        ctx.globalAlpha = opacity;

        const totalLen = data.length;
        if(totalLen < 2) return;

        const endIdx = Math.floor(currentIdx);
        const startIdx = Math.max(0, endIdx - windowSize);
        const loopStart = Math.max(0, startIdx - 2); 
        const calcEnd = Math.min(totalLen - 1, endIdx + 5); 

        // Gap Mode Auto (Leader) - Show only the 2nd place (Chaser) to fix scale
        let activeItems = items;
        if (mode === 'Gap' && config.gapTarget === 'Leader') {
            const row = data[Math.floor(currentIdx)]; 
            if(row) {
                // Find Leader value
                let leaderVal = -Infinity;
                items.forEach(name => {
                    const v = row.values[name];
                    if(v > leaderVal) leaderVal = v;
                });
                
                // Find the closest Chaser (2nd place or max item that is not leader)
                // Since Leader Gap is 0, others are negative. We want the largest negative value (closest to 0).
                let chaserName = null;
                let chaserVal = -Infinity;
                
                items.forEach(name => {
                    const v = row.values[name];
                    // Pick logic: If v < leaderVal (strictly), it is a chaser.
                    if (v < leaderVal && v > chaserVal) {
                        chaserVal = v;
                        chaserName = name;
                    }
                });
                
                // If found, restrict items to this one line so scale adapts to it
                if (chaserName) {
                    activeItems = [chaserName];
                }
            }
        }

        const getValue = (idx, name) => {
            idx = Math.max(0, Math.min(totalLen - 1, idx));
            const row = data[idx];
            if(mode === 'Total') return row.values[name];
            if(mode === 'Diff') return row.diffs[name];
            
            // Gap Mode
            let targetVal = 0;
            if (config.gapTarget === 'Leader') {
                let leader = -Infinity;
                // For logic consistency, targetVal is always current Leader value
                // Note: items here is full items list for leader calc
                for(let m=0; m<items.length; m++) {
                    const v = row.values[items[m]];
                    if(v > leader) leader = v;
                }
                targetVal = leader;
            } else {
                targetVal = row.values[config.gapTarget];
            }
            
            let val = targetVal - row.values[name];
            return items.length === 1 ? 0 : val;
        };

        // SCALE CALCULATION (Use activeItems)
        let targetMin = Infinity;
        let targetMax = -Infinity;
        
        for(let i = loopStart; i <= calcEnd; i++) {
            for(let k=0; k<activeItems.length; k++) {
                const name = activeItems[k];
                // 特定ターゲット指定時の除外
                if (mode === 'Gap' && config.gapTarget !== 'Leader' && name === config.gapTarget) continue;

                const val = getValue(i, name);
                
                if (val < targetMin) targetMin = val;
                if (val > targetMax) targetMax = val;
            }
        }
        
        if(targetMin === Infinity) targetMin = 0;
        if(targetMax === -Infinity) targetMax = 10;
        
        let range = targetMax - targetMin || 10;
        targetMin -= range * 0.1;
        targetMax += range * 0.1;
        if(mode === 'Gap' && targetMin < 0) targetMin = -range * 0.05; 

        // Apply smooth scale change
        scaleState.min = lerp(scaleState.min, targetMin, SCALE_SMOOTHING);
        scaleState.max = lerp(scaleState.max, targetMax, SCALE_SMOOTHING);

        const yMin = scaleState.min;
        const yMax = scaleState.max;
        const yRange = yMax - yMin || 1;

        // PADDING logic
        const paddingTop = 15;
        const paddingBottom = drawXAxis ? 30 : 15;
        const paddingLeft = 0;
        const paddingRight = 10;
        
        const drawH = h - (paddingTop + paddingBottom);
        const drawW = w - (paddingLeft + paddingRight);

        // GRID & LABELS
        ctx.fillStyle = '#555';
        ctx.font = '10px Inter';
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;

        if(mode !== 'Total') {
            const roughStep = yRange / 5; 
            const gridMag = Math.pow(10, Math.floor(Math.log10(roughStep)));
            const norm = roughStep / gridMag;
            let niceStep = (norm<1.5)?1:(norm<3)?2:(norm<7)?5:10;
            const gridStep = niceStep * gridMag;

            const startTick = Math.ceil(yMin / gridStep) * gridStep;
            for(let v = startTick; v <= yMax; v += gridStep) {
                const y = paddingTop + drawH - ((v - yMin) / yRange) * drawH;
                if(y < paddingTop || y > h - paddingBottom) continue; 
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
                ctx.fillText(formatNum(v), 5, y - 4);
            }
        }

        const windowStart = currentIdx - windowSize;

        const getX = (valIdx) => paddingLeft + (valIdx - windowStart) / windowSize * drawW;
        const getY = (val) => paddingTop + drawH - ((val - yMin) / yRange) * drawH;

        // X-AXIS DATES
        if(drawXAxis) {
            ctx.textAlign = 'center';
            const iStart = Math.ceil(windowStart);
            const iEnd = Math.floor(endIdx);
            
            for(let i = iStart; i <= iEnd; i++) {
                if(i < 0 || i >= totalLen) continue;
                const d = data[i].date;
                if(d.getDate() === 1) {
                    const x = getX(i);
                    ctx.beginPath(); 
                    ctx.moveTo(x, paddingTop); 
                    ctx.lineTo(x, h - paddingBottom); 
                    ctx.strokeStyle = 'rgba(255,255,255,0.1)'; 
                    ctx.stroke();
                    
                    ctx.fillStyle = '#888';
                    const mNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
                    const dd = String(d.getDate()).padStart(2, '0');
                    const mm = mNames[d.getMonth()];
                    const yy = String(d.getFullYear()).slice(-2);
                    
                    ctx.fillText(`${dd}-${mm}-${yy}`, x, h - 10);
                }
            }
            ctx.textAlign = 'left'; 
        }

        // LINES (Draw activeItems)
        for(let k=0; k<activeItems.length; k++) {
            const name = activeItems[k];
            
            // Specific logic: If this item IS the target in fixed mode, skip.
            if (mode === 'Gap' && config.gapTarget !== 'Leader' && name === config.gapTarget) continue;

            ctx.beginPath();
            ctx.strokeStyle = colors[name];
            ctx.lineWidth = lineWidth;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            let lastX, lastY;
            let started = false;

            const processPoint = (i, isTip) => {
                let val;
                if(isTip) {
                    const idxLow = Math.floor(i);
                    const idxHigh = Math.min(totalLen - 1, idxLow + 1);
                    const r = i - idxLow;
                    val = lerp(getValue(idxLow, name), getValue(idxHigh, name), r);
                } else {
                    val = getValue(i, name);
                }

                const x = getX(i);
                const y = getY(val);

                if(!started) {
                    ctx.moveTo(x, y);
                    started = true;
                } else {
                    const midX = (lastX + x) / 2;
                    const midY = (lastY + y) / 2;
                    ctx.quadraticCurveTo(lastX, lastY, midX, midY);
                }
                lastX = x; lastY = y;
            };

            for(let i = loopStart; i <= endIdx; i++) processPoint(i, false);
            if(currentIdx > endIdx) processPoint(currentIdx, true);
            
            if(started) {
                ctx.lineTo(lastX, lastY);
                ctx.stroke();
                if(mode !== 'Total') {
                    ctx.fillStyle = colors[name];
                    ctx.beginPath(); ctx.arc(lastX, lastY, 4, 0, Math.PI * 2); ctx.fill();
                }
            }
        }
    }

    // --- Result Chart ---
    class InteractiveChart {
        constructor(canvas, mode) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.mode = mode;
            this.dataPoints = [];
        }

        handleInteraction(x, y) {
            const rect = this.canvas.getBoundingClientRect();
            if(x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                const len = this.dataPoints.length;
                const ratio = (x - rect.left) / rect.width;
                const idx = Math.max(0, Math.min(len-1, Math.floor(ratio * (len-1))));
                this.draw(idx);
                this.showTooltipDOM(x - rect.left, y - rect.top, idx, rect);
                return true;
            }
            return false;
        }

        checkHover(cx, cy) {
            return this.handleInteraction(cx, cy);
        }

        clearHighlight() { this.draw(-1); }

        init(data, items) {
            this.dataPoints = [];
            let minVal = Infinity, maxVal = -Infinity;
            for(let i=0; i<data.length; i++) {
                const row = data[i];
                let rowObj = { date: row.date, values: {} };
                
                let targetVal = 0;
                if (config.gapTarget === 'Leader') {
                    let leader = -Infinity;
                    if(this.mode === 'Gap') items.forEach(n => { if(row.values[n]>leader) leader = row.values[n]; });
                    targetVal = leader;
                } else {
                    targetVal = row.values[config.gapTarget];
                }

                items.forEach(name => {
                    let v;
                    if(this.mode==='Total') v = row.values[name];
                    else if(this.mode==='Diff') v = row.diffs[name];
                    else v = Math.max(0, targetVal - row.values[name]);
                    
                    rowObj.values[name] = v;
                    
                    if (this.mode === 'Gap' && config.gapTarget !== 'Leader' && name === config.gapTarget) return;

                    if(v < minVal) minVal = v;
                    if(v > maxVal) maxVal = v;
                });
                this.dataPoints.push(rowObj);
            }
            
            let range = maxVal - minVal || 10;
            const buffer = range * 0.1;
            this.yMin = (this.mode==='Gap' && minVal < 10) ? -buffer/2 : minVal - buffer;
            this.yMax = maxVal + buffer;
            this.yRange = this.yMax - this.yMin;
            
            setupCanvas(this.canvas, this.ctx);
            this.draw();
        }

        showTooltipDOM(relX, relY, idx, rect) {
            const dp = this.dataPoints[idx];
            tooltip.style.display = 'block';
            
            const globalX = rect.left + relX;
            const globalY = rect.top + relY;
            
            let html = `<div class="tt-date">${formatDate(dp.date)}</div>`;
            let sorted = itemsList.map(n => ({n, v: dp.values[n]}))
                                  .sort((a,b) => (this.mode==='Gap' ? a.v - b.v : b.v - a.v)).slice(0, 8); 
            sorted.forEach(item => {
                html += `<div class="tt-row"><span style="color:${colors[item.n]}">${item.n}</span><span class="tt-val">${Math.floor(item.v).toLocaleString()}</span></div>`;
            });
            tooltip.innerHTML = html;

            const ttRect = tooltip.getBoundingClientRect();
            const winW = window.innerWidth;
            
            let finalLeft = globalX + 15;
            if (finalLeft + ttRect.width > winW - 10) {
                finalLeft = globalX - ttRect.width - 15;
            }
            
            tooltip.style.left = finalLeft + 'px';
            tooltip.style.top = (globalY + 15) + 'px';
        }

        draw(hoverIdx = -1) {
            const w = this.canvas.logicalWidth;
            const h = this.canvas.logicalHeight;
            const ctx = this.ctx;
            const len = this.dataPoints.length;
            ctx.clearRect(0,0,w,h);
            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = 1;
            ctx.fillStyle = '#666';
            ctx.font = '10px Inter';

            const padding = 20; 
            const drawH = h - (padding * 2);
            const getY = (val) => padding + drawH - ((val - this.yMin) / this.yRange) * drawH;

            const step = this.yRange / 5;
            const startTick = Math.ceil(this.yMin / step) * step;
            for(let v = startTick; v <= this.yMax; v += step) {
                const y = getY(v);
                if(y < 5 || y > h - 5) continue;
                ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
                ctx.fillText(formatNum(v), 5, y-4);
            }

            itemsList.forEach(name => {
                if (this.mode === 'Gap' && config.gapTarget !== 'Leader' && name === config.gapTarget) return;

                ctx.beginPath(); 
                ctx.strokeStyle = colors[name]; 
                ctx.lineWidth = 2;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';

                let lastX, lastY;
                let started = false;

                for(let i = 0; i < len; i++) {
                    const x = (i / (len-1)) * w;
                    const val = this.dataPoints[i].values[name];
                    const y = getY(val);

                    if(!started) { 
                        ctx.moveTo(x, y); 
                        started = true; 
                    } else {
                        const midX = (lastX + x) / 2;
                        const midY = (lastY + y) / 2;
                        ctx.quadraticCurveTo(lastX, lastY, midX, midY);
                    }
                    lastX = x; lastY = y;
                }
                if(started) ctx.lineTo(lastX, lastY);
                ctx.stroke();
            });

            if(hoverIdx >= 0) {
                const x = (hoverIdx / (len - 1)) * w;
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h);
                ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
            }
        }
    }

    // --- Result Screen Logic ---
    function showResultScreen() {
        resultScreen.style.display = 'flex';
        setTimeout(() => resultScreen.style.opacity = 1, 10);
        if(!chartTotal) {
            chartTotal = new InteractiveChart(resCanvasTotal, 'Total');
            chartGain = new InteractiveChart(resCanvasGain, 'Diff');
            chartGap = new InteractiveChart(resCanvasGap, 'Gap');
        }
        requestAnimationFrame(() => {
            setupCanvas(resCanvasTotal, resCanvasTotal.getContext('2d'));
            setupCanvas(resCanvasGain, resCanvasGain.getContext('2d'));
            setupCanvas(resCanvasGap, resCanvasGap.getContext('2d'));
            chartTotal.init(processedData, itemsList);
            chartGain.init(processedData, itemsList);
            chartGap.init(processedData, itemsList);
        });
    }

    function handleResultInteraction(clientX, clientY) {
        if(resultScreen.style.display === 'none') return;
        let anyHover = false;
        if(chartTotal && chartTotal.checkHover(clientX, clientY)) anyHover = true;
        if(chartGain && chartGain.checkHover(clientX, clientY)) anyHover = true;
        if(chartGap && chartGap.checkHover(clientX, clientY)) anyHover = true;
        if(!anyHover) tooltip.style.display = 'none';
    }

    window.addEventListener('mousemove', (e) => {
        handleResultInteraction(e.clientX, e.clientY);
    });

    window.addEventListener('touchstart', (e) => {
        if(e.touches.length > 0) {
            handleResultInteraction(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, {passive: true});

    window.addEventListener('touchmove', (e) => {
        if(e.touches.length > 0) {
            handleResultInteraction(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, {passive: true});


    replayBtn.addEventListener('click', () => {
        resultScreen.style.opacity = 0;
        setTimeout(() => resultScreen.style.display = 'none', 300);
        animationTime = 0;
        isPlaying = true;
        playPauseBtn.innerHTML = '<i class="bi bi-pause-fill"></i>';
        lastFrameTime = performance.now();
        seekSlider.value = 0;
        seekVal.textContent = "0%";
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = requestAnimationFrame(gameLoop);
    });

    // --- Common Helpers ---
    function setupCanvas(canvas, ctx) {
        if(!canvas.parentElement) return;
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        canvas.logicalWidth = rect.width;
        canvas.logicalHeight = rect.height;
    }

    function resizeAllCanvases() {
        setupCanvas(bgCanvas, bgCtx);
        setupCanvas(dailyCanvas, dailyCtx);
        if(chartTotal) { setupCanvas(resCanvasTotal, chartTotal.ctx); chartTotal.draw(-1); }
        if(chartGain) { setupCanvas(resCanvasGain, chartGain.ctx); chartGain.draw(-1); }
        if(chartGap) { setupCanvas(resCanvasGap, chartGap.ctx); chartGap.draw(-1); }
    }
    window.addEventListener('resize', resizeAllCanvases);

    function parseCSV(text) {
        try {
            const lines = text.trim().split(/\r\n|\n/);
            const headerParts = lines[0].split(',');
            const colorParts = lines[2].split(',');
            const clean = s => s ? s.replace(/^"|"$/g, '').trim() : '';
            itemsList = []; itemImages = {};
            for(let i=1; i<headerParts.length; i++) {
                const name = clean(headerParts[i]);
                if(name) { itemsList.push(name); colors[name] = clean(colorParts[i]) || '#fff'; }
            }
            let tempRaw = [];
            for(let i=3; i<lines.length; i++) {
                const parts = lines[i].split(',');
                const firstCol = clean(parts[0]);
                if(firstCol.toLowerCase() === 'image' || firstCol.toLowerCase() === 'icon') {
                    for(let k=1; k<parts.length; k++) if(k <= itemsList.length) itemImages[itemsList[k-1]] = clean(parts[k]);
                    continue;
                }
                const dateObj = new Date(firstCol);
                if(isNaN(dateObj.getTime())) continue;
                let row = { date: dateObj, values: {}, total: 0 };
                itemsList.forEach((name, idx) => {
                    const val = parseInt(clean(parts[idx+1])) || 0;
                    row.values[name] = val; row.total += val;
                });
                tempRaw.push(row);
            }
            processedData = tempRaw.map((curr, i) => {
                let diffs = {};
                itemsList.forEach(name => {
                    const prevVal = i > 0 ? tempRaw[i-1].values[name] : curr.values[name];
                    diffs[name] = curr.values[name] - prevVal;
                });
                return { ...curr, diffs };
            });
            return true;
        } catch(e) { return false; }
    }

    function createDOMBars() {
        barsContainer.innerHTML = ''; barElements = {};
        itemsList.forEach(name => {
            const row = document.createElement('div'); row.className = 'bar-row';
            const wrapper = document.createElement('div'); wrapper.className = 'bar-wrapper';
            const bar = document.createElement('div'); bar.className = 'bar'; bar.style.backgroundColor = colors[name];
            const img = document.createElement('img'); img.className = 'bar-img'; if(itemImages[name]) img.src = itemImages[name];
            const labelIn = document.createElement('div'); labelIn.className = 'bar-label-in';
            const vals = document.createElement('div'); vals.className = 'bar-values';
            const mVal = document.createElement('div'); mVal.className = 'val-main';
            const labelOut = document.createElement('div'); labelOut.className = 'label-popout';
            const subGroup = document.createElement('div'); subGroup.className = 'val-sub-group';
            const sVal = document.createElement('div'); sVal.className = 'val-sub'; 
            const gVal = document.createElement('div'); gVal.className = 'val-gap'; 
            subGroup.append(sVal, gVal); vals.append(mVal, labelOut, subGroup);
            bar.append(img, labelIn, vals); wrapper.append(bar); row.append(wrapper); barsContainer.append(row);
            barElements[name] = { row, bar, img, labelIn, labelOut, mVal, sVal, gVal };
        });
    }

    playPauseBtn.addEventListener('click', () => {
        if(animationTime >= TOTAL_DURATION_BASE && !isPlaying) animationTime = 0;
        isPlaying = !isPlaying;
        playPauseBtn.innerHTML = isPlaying ? '<i class="bi bi-pause-fill"></i>' : '<i class="bi bi-play-fill"></i>';
        if(isPlaying) { lastFrameTime = performance.now(); animationFrameId = requestAnimationFrame(gameLoop); }
    });

    seekSlider.addEventListener('input', (e) => {
        animationTime = (parseFloat(e.target.value) / 100) * TOTAL_DURATION_BASE;
        renderFrame();
    });

    modeBtn.addEventListener('click', () => {
        isGapMode = !isGapMode;
        modeBtn.innerHTML = isGapMode ? '<i class="bi bi-distribute-vertical"></i> Gap Mode' : '<i class="bi bi-list-ol"></i> Total Mode';
        modeBtn.className = isGapMode ? 'icon-btn active' : 'icon-btn';
        bottomGraphTitle.innerHTML = isGapMode ? `<i class="bi bi-distribute-vertical"></i> Gap to Target` : `<i class="bi bi-graph-up"></i> ${config.bottomTitle}`;
        renderFrame();
    });

    function lerp(a, b, t) { return a + (b - a) * t; }
    function formatDate(d) {
        const m = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
        return `${m[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()}`;
    }
    function formatNum(n) {
        if(Math.abs(n) >= 1e9) return (n/1e9).toFixed(1).replace('.0','') + 'B';
        if(Math.abs(n) >= 1e6) return (n/1e6).toFixed(1).replace('.0','') + 'M';
        if(Math.abs(n) >= 1e3) return (n/1e3).toFixed(1).replace('.0','') + 'K';
        return Math.floor(n).toLocaleString();
    }
    
    function renderAxisNice(maxVal) {
        axisContainer.innerHTML = '';
        const ticks = 5;
        const roughStep = maxVal / (ticks - 1);
        const mag = Math.pow(10, Math.floor(Math.log10(roughStep)));
        let niceStep = (roughStep/mag < 1.5) ? 1 : (roughStep/mag < 3) ? 2 : (roughStep/mag < 7) ? 5 : 10;
        const step = niceStep * mag;
        for(let v=0; v < maxVal; v+=step) {
            const pct = (v/maxVal)*100;
            const l = document.createElement('div'); l.className='grid-line'; l.style.left=pct+'%';
            const t = document.createElement('div'); t.className='axis-label'; t.textContent=formatNum(v); t.style.left=pct+'%';
            axisContainer.append(l, t);
        }
    }

</script>
</body>
</html>
