<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<!-- iPad/iPhone対応 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Pro Visualizer: Ultimate JP</title>
<!-- Bootstrap Icons CDN -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap');

    :root {
        --color-bg: #0d0d0d;
        --color-panel: #1a1a1a;
        --color-panel-border: #333;
        --color-text: #ffffff;
        --color-green: #00e676;
        --color-red: #ff5252;
        --color-blue: #2979ff;
        --color-sub: #888;
        --font-main: 'Inter', sans-serif; /* 日本語フォントはOS標準にフォールバック */
    }

    * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

    body {
        background-color: var(--color-bg);
        color: var(--color-text);
        font-family: var(--font-main), "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
        margin: 0;
        overflow: hidden;
        width: 100vw;
        height: 100vh;
        display: flex;
        flex-direction: column;
        /* 数字のガタつき防止 */
        font-variant-numeric: tabular-nums;
    }

    /* --- Overlays --- */
    .overlay-screen {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.95);
        z-index: 9999;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: opacity 0.3s;
        backdrop-filter: blur(5px);
    }

    .modal-box {
        background: var(--color-panel);
        padding: 40px;
        border-radius: 24px;
        text-align: center;
        border: 1px solid var(--color-panel-border);
        box-shadow: 0 20px 60px rgba(0,0,0,0.6);
        width: 90%;
        max-width: 600px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        max-height: 90vh;
        overflow-y: auto;
    }
    
    .modal-box::-webkit-scrollbar { width: 8px; }
    .modal-box::-webkit-scrollbar-track { background: #111; }
    .modal-box::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }

    h2 { margin: 0; font-weight: 900; letter-spacing: -0.5px; }
    p.sub { color: #888; font-size: 14px; margin: 0; }

    /* Upload Specific */
    .file-label {
        display: flex; align-items: center; justify-content: center; gap: 10px;
        padding: 18px 30px;
        background: #222;
        color: var(--color-green);
        border: 2px dashed #444;
        border-radius: 16px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 700;
        transition: all 0.2s;
    }
    .file-label:hover { background: #2a2a2a; border-color: var(--color-green); }
    input[type="file"] { display: none; }

    .action-btn {
        padding: 16px 40px;
        background: var(--color-green);
        color: #000;
        border: none;
        border-radius: 50px;
        font-weight: 900;
        font-size: 18px;
        cursor: pointer;
        display: flex; align-items: center; justify-content: center; gap: 10px;
        transition: transform 0.1s, filter 0.2s;
        width: 100%;
    }
    .action-btn:active { transform: scale(0.98); filter: brightness(0.9); }
    .action-btn.secondary { background: #333; color: #fff; }

    /* --- Settings Screen --- */
    .settings-grid {
        display: grid;
        grid-template-columns: 1fr 1fr; /* 2列に変更 */
        gap: 15px;
        text-align: left;
        width: 100%;
    }
    .settings-full-width {
        grid-column: 1 / -1;
    }

    .setting-item {
        background: #222;
        padding: 12px 15px;
        border-radius: 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .setting-label { font-weight: 600; font-size: 13px; display: flex; align-items: center; gap: 8px; color:#ddd; }
    
    .text-input, .select-input {
        background: #111; border: 1px solid #444;
        color: #fff; padding: 8px 10px; border-radius: 8px;
        width: 100%; font-family: inherit; font-size: 14px;
    }
    .select-input { cursor: pointer; }

    /* Toggle Switch */
    .toggle-switch {
        position: relative; width: 46px; height: 24px; flex-shrink: 0;
    }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .slider {
        position: absolute; cursor: pointer;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: #444;
        transition: .3s; border-radius: 30px;
    }
    .slider:before {
        position: absolute; content: "";
        height: 18px; width: 18px;
        left: 3px; bottom: 3px;
        background-color: white;
        transition: .3s; border-radius: 50%;
    }
    input:checked + .slider { background-color: var(--color-green); }
    input:checked + .slider:before { transform: translateX(22px); }

    /* --- Result Overlay --- */
    #result-screen {
        z-index: 2000;
        display: none; 
        flex-direction: column;
        padding: 20px;
    }
    .result-header {
        display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;
    }
    .result-title { 
        font-size: 28px; font-weight: 900; color: #fff; 
        border-left: 6px solid var(--color-green); padding-left: 15px; 
    }
    
    .result-grid {
        flex: 1;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        grid-template-rows: repeat(2, 1fr);
        gap: 20px;
        width: 100%; max-width: 1600px; margin: 0 auto;
        min-height: 0;
    }
    .res-card {
        background: #151515; border: 1px solid #333;
        border-radius: 16px; padding: 20px;
        display: flex; flex-direction: column;
        position: relative;
        overflow: hidden;
    }
    .res-card.full-width { grid-column: 1 / -1; }
    
    .res-head { font-size: 16px; color: #ccc; font-weight: bold; margin-bottom: 15px; display: flex; align-items: center; gap: 10px; }
    .res-canvas-container { 
        flex: 1; position: relative; width: 100%; min-height: 0; 
        cursor: crosshair; touch-action: none;
    }
    .res-canvas { width: 100%; height: 100%; display: block; }
    
    /* Tooltip */
    #tooltip {
        position: absolute;
        background: rgba(0,0,0,0.9);
        border: 1px solid #555;
        padding: 8px 12px;
        border-radius: 8px;
        pointer-events: none;
        display: none;
        font-size: 12px;
        font-family: var(--font-main);
        font-variant-numeric: tabular-nums;
        z-index: 9999;
        box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        white-space: nowrap;
    }
    .tt-date { color: #888; margin-bottom: 4px; font-weight: bold; }
    .tt-row { display: flex; justify-content: space-between; gap: 15px; margin-bottom: 2px; }
    .tt-val { font-weight: 700; color: #fff; }

    /* --- Main UI --- */
    #main-container {
        flex: 1; display: flex; flex-direction: column;
        padding: 10px 20px; position: relative;
    }

    .header { height: 60px; display: flex; justify-content: space-between; align-items: center; z-index: 10; }
    .main-title { 
        font-size: 24px; font-weight: 900; 
        border-left: 5px solid var(--color-green); padding-left: 15px; letter-spacing: -0.5px;
    }
    #date-display { 
        font-size: 36px; font-weight: 900; 
        font-variant-numeric: tabular-nums; 
        text-align: right; letter-spacing: -1px; 
    }

    /* Chart Area */
    #chart-area { 
        position: relative; flex: 2; 
        margin: 10px 10px 0 10px; 
        /* Axis表示のために上部にスペースを確保 */
        padding-top: 30px; 
        overflow: hidden; 
    }
    
    #bg-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; opacity: 0.5; }
    
    /* Axisを可視領域内に配置 */
    #axis-container { 
        position: absolute; top: 0; left: 0; width: 100%; height: 30px; z-index: 2; 
        pointer-events: none;
    }
    .grid-line { position: absolute; top: 30px; bottom: -100vh; width: 1px; background: rgba(255,255,255,0.08); z-index: 1; }
    .axis-label { 
        position: absolute; top: 5px; transform: translateX(-50%); 
        font-size: 12px; color: #666; font-weight: 700; 
    }

    /* バーのコンテナ：見切れ防止のため右パディングを増やす */
    #bars-container { 
        position: relative; width: 100%; height: 100%; z-index: 5; 
        padding-right: 220px; /* 値が見切れないように十分な余白 */
    }
    .bar-row { 
        position: absolute; left: 0; width: 100%; height: 60px; display: flex; align-items: center; 
        will-change: transform; 
    }
    
    .bar-wrapper { flex: 1; height: 100%; position: relative; display: flex; align-items: center; }
    
    .bar {
        height: 42px; 
        border-radius: 6px; 
        position: relative;
        box-shadow: 4px 4px 15px rgba(0,0,0,0.4);
        will-change: width; transition: background-color 0.2s;
        min-width: 0; 
        display: flex; align-items: center;
        justify-content: flex-end; 
        padding-right: 15px; 
        overflow: visible; 
    }

    .bar-img {
        position: absolute; left: -2px; top: 50%; transform: translateY(-50%);
        width: 36px; height: 36px; border-radius: 50%;
        background: #000; border: 2px solid #fff;
        object-fit: cover; z-index: 5;
        display: none;
    }

    .bar-label-in {
        font-weight: 900; font-size: 20px; 
        white-space: nowrap; z-index: 4;
        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        transition: color 0.2s;
        margin-right: auto; padding-left: 10px; /* 左寄せに変更 */
    }
    
    .label-popout {
        position: absolute; left: 100%; top: 50%; transform: translateY(-50%);
        margin-left: 10px;
        background: rgba(0,0,0,0.6); padding: 4px 8px; border-radius: 4px;
        color: #fff !important; font-size: 14px;
        display: flex; align-items: center;
        white-space: nowrap;
        z-index: 10;
    }

    /* Updated Value Layout */
    .bar-values {
        position: absolute; left: 100%; margin-left: 12px;
        display: flex; flex-direction: column; justify-content: center;
        line-height: 1.1; white-space: nowrap;
        align-items: flex-start; /* 左揃え */
    }
    
    .val-row-main { display: flex; align-items: baseline; gap: 8px; }
    .val-row-sub  { display: flex; align-items: baseline; gap: 8px; margin-top: 2px; }

    /* Font sizes managed by JS dynamically */
    .val-main { font-weight: 900; color: #fff; letter-spacing: -0.5px; transition: font-size 0.1s; }
    .val-diff { font-weight: 700; color: var(--color-green); transition: font-size 0.1s; }
    .val-diff.negative { color: var(--color-red); }

    .val-gap-label { font-size: 10px; color: #666; font-weight: 700; margin-right: 2px; }
    .val-gap { font-weight: 700; color: #ccc; transition: font-size 0.1s; }
    .val-gap-diff { font-weight: 700; color: var(--color-sub); transition: font-size 0.1s; }
    .val-gap-diff.positive { color: var(--color-red); } /* Gapが増える＝悪い */
    .val-gap-diff.negative { color: var(--color-blue); } /* Gapが減る＝良い */

    /* Bottom Info */
    .bottom-section {
        flex: none; height: 220px; display: flex; gap: 15px;
        background: rgba(255,255,255,0.02);
        border-radius: 12px; margin: 10px 10px 0 10px; 
        padding: 10px; border: 1px solid #222;
        position: relative;
    }
    .daily-graph-box { flex: 2.5; position: relative; display: flex; flex-direction: column; }
    .graph-header { font-size: 14px; color: #888; font-weight: bold; margin-bottom: 5px; display: flex; align-items: center; gap: 8px; }
    #daily-canvas { flex: 1; width: 100%; }
    
    .combined-box { 
        flex: 1; display: flex; flex-direction: column; justify-content: center; align-items: flex-end; text-align: right; 
        min-width: 0; overflow: hidden;
    }
    .stat-label { font-size: 12px; color: #666; font-weight: 700; letter-spacing: 0.5px; }
    .total-group { display: flex; align-items: baseline; gap: 10px; width: 100%; justify-content: flex-end; }
    .stat-val { font-weight: 900; color: #fff; letter-spacing: -0.5px; transition: font-size 0.1s; }
    .stat-gain { font-weight: 700; color: var(--color-green); transition: font-size 0.1s; }
    .stat-gain.negative { color: var(--color-red); }

    /* Controls */
    #controls-bar {
        height: 90px; background: #0a0a0a;
        display: flex; align-items: center;
        padding: 0 20px; gap: 15px;
        border-top: 1px solid #222;
        z-index: 100; box-shadow: 0 -10px 30px rgba(0,0,0,0.5);
    }
    .control-group { display: flex; flex-direction: column; justify-content: center; color: #888; font-size: 11px; font-weight: bold; min-width: 70px; }
    .control-row { display: flex; justify-content: space-between; width: 100%; margin-bottom: 6px; }

    input[type=range] {
        -webkit-appearance: none; background: transparent;
        height: 24px; width: 100%; cursor: pointer; margin: 0;
    }
    input[type=range]:focus { outline: none; }
    input[type=range]::-webkit-slider-runnable-track {
        width: 100%; height: 8px; cursor: pointer;
        background: #333; border-radius: 4px; transition: 0.2s;
    }
    input[type=range]::-webkit-slider-thumb {
        height: 20px; width: 20px; border-radius: 50%;
        background: var(--color-green); cursor: pointer;
        -webkit-appearance: none; margin-top: -6px; 
        box-shadow: 0 0 10px rgba(0,230,118,0.5); transition: transform 0.1s;
    }
    input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); }
    
    #seek-slider { width: 140px; }
    #speed-slider { width: 100px; }

    .icon-btn {
        background: #222; color: #fff;
        border: 1px solid #333; padding: 0 12px;
        height: 40px; border-radius: 8px; font-size: 13px; font-weight: 700;
        cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px;
        transition: 0.2s;
    }
    .icon-btn:hover { background: #333; border-color: #555; }
    .icon-btn.active { background: var(--color-green); color: #000; border-color: var(--color-green); }

    #play-pause-btn {
        width: 60px; height: 60px; border-radius: 50%;
        font-size: 32px; background: #222; color: var(--color-green);
        border: 2px solid #333; margin-right: 5px;
        padding: 0; display: flex; align-items: center; justify-content: center;
        transition: all 0.2s; flex-shrink: 0;
    }
    #play-pause-btn:hover { background: #2a2a2a; border-color: var(--color-green); transform: scale(1.05); }
    
    .file-btn-group { display: flex; gap: 8px; }
    .separator { width: 1px; height: 40px; background: #333; }

</style>
</head>
<body>

    <!-- Tooltip -->
    <div id="tooltip"></div>

    <!-- Upload Screen -->
    <div id="upload-screen" class="overlay-screen">
        <div class="modal-box">
            <div>
                <h2>Pro Visualizer</h2>
                <p class="sub">Ultimate Edition JP</p>
            </div>
            
            <label for="file-input" class="file-label">
                <i class="bi bi-folder2-open" style="font-size:20px;"></i> CSVファイルを選択
            </label>
            <input type="file" id="file-input" accept=".csv, text/csv, text/plain, */*">
            
            <div id="file-name" style="color:#fff; font-size:14px; font-weight:bold; min-height:20px;"></div>
            
            <button id="to-settings-btn" class="action-btn" style="display:none;">
                次へ <i class="bi bi-arrow-right-circle-fill"></i>
            </button>
        </div>
    </div>

    <!-- Settings Screen -->
    <div id="settings-screen" class="overlay-screen" style="display:none;">
        <div class="modal-box">
            <h2><i class="bi bi-gear-fill"></i> 詳細設定</h2>
            
            <div class="settings-grid">
                <!-- Title -->
                <div class="setting-item settings-full-width" style="flex-direction:column; align-items:flex-start; gap:10px;">
                    <span class="setting-label"><i class="bi bi-type-h1"></i> タイトル</span>
                    <input type="text" id="config-title" class="text-input" value="Subscriber Race">
                </div>
                
                <!-- Bottom Graph Label -->
                <div class="setting-item" style="flex-direction:column; align-items:flex-start; gap:10px;">
                    <span class="setting-label"><i class="bi bi-tag"></i> 下部グラフのラベル</span>
                    <input type="text" id="config-bottom-title" class="text-input" value="Daily Gain">
                </div>

                <!-- Total Value Label -->
                <div class="setting-item" style="flex-direction:column; align-items:flex-start; gap:10px;">
                    <span class="setting-label"><i class="bi bi-tag"></i> 合計値のラベル</span>
                    <input type="text" id="config-total-label" class="text-input" value="Combined Total">
                </div>
                
                <!-- Gap Target Selection -->
                <div class="setting-item" style="flex-direction:column; align-items:flex-start; gap:10px;">
                    <span class="setting-label"><i class="bi bi-crosshair"></i> Gap比較対象</span>
                    <select id="config-gap-target" class="select-input">
                        <option value="Leader">1位 (自動)</option>
                    </select>
                </div>

                <!-- History Window -->
                <div class="setting-item" style="flex-direction:column; align-items:flex-start; gap:10px;">
                    <span class="setting-label"><i class="bi bi-hourglass-split"></i> 履歴ウィンドウ (日数)</span>
                    <div style="display:flex; width:100%; gap:10px; align-items:center;">
                        <input type="range" id="config-history-slider" min="10" max="500" value="100" style="flex:1;">
                        <input type="number" id="config-history-input" value="100" min="10" step="1" style="width:70px; text-align:right;" class="text-input">
                    </div>
                </div>

                <!-- Duration Setting -->
                <div class="setting-item" style="flex-direction:column; align-items:flex-start; gap:10px;">
                    <span class="setting-label"><i class="bi bi-stopwatch"></i> レース時間 (秒)</span>
                    <div style="display:flex; width:100%; gap:10px; align-items:center;">
                        <input type="range" id="config-duration-slider" min="60" max="600" step="10" value="300" style="flex:1;">
                        <div style="display:flex; align-items:center; gap:5px;">
                            <input type="number" id="config-duration-input" value="300" style="width:70px; text-align:right;" class="text-input">
                        </div>
                    </div>
                </div>

                <!-- Switches -->
                <div class="setting-item">
                    <span class="setting-label"><i class="bi bi-image"></i> アイコン表示</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="config-icons" checked>
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="setting-item">
                    <span class="setting-label"><i class="bi bi-distribute-vertical"></i> Gap詳細表示</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="config-show-gap-detail" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <div class="setting-item">
                    <span class="setting-label"><i class="bi bi-clipboard-data"></i> 結果画面を表示</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="config-result" checked>
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="setting-item">
                    <span class="setting-label"><i class="bi bi-graph-up"></i> 下部グラフ表示</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="config-bottom-graph" checked>
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="setting-item">
                    <span class="setting-label"><i class="bi bi-bar-chart-steps"></i> 背景グラフ表示</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="config-bg-graph" checked>
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="setting-item">
                    <span class="setting-label"><i class="bi bi-calculator"></i> 合計値を表示</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="config-total" checked>
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="setting-item settings-full-width">
                     <span class="setting-label"><i class="bi bi-palette"></i> グラフ線の太さ</span>
                     <div style="display:flex; width:100%; gap:10px; align-items:center;">
                        <input type="range" id="config-line-width" min="1" max="10" value="4" style="flex:1;">
                     </div>
                </div>
            </div>

            <button id="start-btn" class="action-btn">
                <i class="bi bi-play-circle-fill"></i> スタート
            </button>
        </div>
    </div>

    <!-- Result Screen -->
    <div id="result-screen" class="overlay-screen">
        <div style="width:100%; max-width:1600px; display:flex; flex-direction:column; height:90%;">
            <div class="result-header">
                <div style="display:flex; align-items:center;">
                    <div class="result-title">最終結果</div>
                </div>
                <div style="display:flex; align-items:center; gap:10px;">
                    <button id="change-file-result-btn" class="icon-btn">
                        <i class="bi bi-folder2-open"></i> 開く
                    </button>
                    <button id="replay-btn" class="action-btn secondary" style="width:auto;">
                        <i class="bi bi-arrow-counterclockwise"></i> リプレイ
                    </button>
                </div>
            </div>
            <div class="result-grid">
                <!-- Full Width: Total -->
                <div class="res-card full-width">
                    <div class="res-head"><i class="bi bi-bar-chart-line-fill"></i> 全期間合計</div>
                    <div class="res-canvas-container" id="con-total">
                        <canvas id="res-canvas-total" class="res-canvas"></canvas>
                    </div>
                </div>
                <!-- Half: Daily Gain -->
                <div class="res-card">
                    <div class="res-head"><i class="bi bi-graph-up-arrow"></i> 日次推移</div>
                    <div class="res-canvas-container" id="con-gain">
                        <canvas id="res-canvas-gain" class="res-canvas"></canvas>
                    </div>
                </div>
                <!-- Half: Gap -->
                <div class="res-card">
                    <div class="res-head"><i class="bi bi-distribute-vertical"></i> 1位との差 (Gap)</div>
                    <div class="res-canvas-container" id="con-gap">
                        <canvas id="res-canvas-gap" class="res-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div id="main-container">
        <div class="header">
            <div class="main-title" id="disp-title">Subscriber Race</div>
            <div id="date-display">--</div>
        </div>

        <div id="chart-area">
            <!-- Background Graph -->
            <canvas id="bg-canvas"></canvas>
            <!-- Axis & Bars -->
            <div id="axis-container"></div>
            <div id="bars-container"></div>
        </div>

        <div class="bottom-section" id="bottom-section">
            <div class="daily-graph-box" id="daily-graph-box">
                <div class="graph-header">
                    <span id="bottom-graph-title"><i class="bi bi-graph-up"></i> Daily Gain</span>
                </div>
                <canvas id="daily-canvas"></canvas>
            </div>
            <div class="combined-box" id="combined-box">
                <div class="stat-label" id="stat-label-el">Combined Total</div>
                <div class="total-group">
                    <div class="stat-val" id="combined-display">0</div>
                    <div class="stat-gain" id="combined-gain"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="controls-bar">
        <div class="file-btn-group">
            <button id="change-file-btn" class="icon-btn" title="ファイルを開く"><i class="bi bi-folder2-open"></i></button>
            <button id="open-settings-btn" class="icon-btn" title="設定"><i class="bi bi-gear-fill"></i></button>
            <button id="restart-btn" class="icon-btn" title="リスタート"><i class="bi bi-skip-start-fill"></i></button>
        </div>
        
        <button id="play-pause-btn"><i class="bi bi-play-fill"></i></button>
        
        <div class="control-group" style="flex:1;">
            <div class="control-row">
                <span>SEEK</span>
                <span id="seek-val">0%</span>
            </div>
            <input type="range" id="seek-slider" min="0" max="100" step="0.01" value="0">
        </div>
        
        <div class="separator"></div>

        <div class="control-group">
            <div class="control-row">
                <span>SPEED</span>
                <span id="speed-display">1.0x</span>
            </div>
            <input type="range" id="speed-slider" min="0" max="100" step="0.1" value="50">
        </div>

        <div class="separator"></div>
        
        <!-- Dynamic Target Select -->
        <div class="control-group" style="min-width: 100px;">
             <div class="control-row"><span>TARGET (Gap)</span></div>
             <select id="dynamic-gap-target" class="select-input" style="height:30px; padding:0 5px; font-size:12px;">
                 <option value="Leader">1位 (自動)</option>
             </select>
        </div>

        <div class="control-group" style="min-width:110px;">
            <div class="control-row"><span>MODE</span></div>
            <button id="mode-btn" class="icon-btn" style="width:100%;">
                <i class="bi bi-list-ol"></i> 通常モード
            </button>
        </div>
    </div>

<script>
    // --- Configuration & Constants ---
    let TOTAL_DURATION_BASE = 300000; 
    let HISTORY_WINDOW = 100; 

    // User Config
    const config = {
        title: "Subscriber Race",
        bottomTitle: "Daily Gain",
        totalLabel: "Combined Total",
        gapTarget: "Leader", 
        showGapDetail: true,
        showResult: true,
        showBottomGraph: true,
        showBgGraph: true,
        showTotal: true,
        showIcons: true,
        graphLineWidth: 4
    };

    // --- Suffixes List (10^3 to 10^306) ---
    const SUFFIXES = [
        "K", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", 
        "Dc", "Ud", "Dd", "Td", "Qad", "Qid", "Sxd", "Spd", "Ocd", "Nod", 
        "Vg", "Uvg", "Dvg", "Tvg", "Qavg", "Qivg", "Sxvg", "Spvg", "Ocvg", "Novg", 
        "Tg", "Utg", "Dtg", "Ttg", "Qatg", "Qitg", "Sxtg", "Sptg", "Octg", "Notg", 
        "Qg", "Uqg", "Dqg", "Tqg", "Qaqg", "Qiqg", "Sxqg", "Spqg", "Ocqg", "Noqg", 
        "Qq", "Uqq", "Dqq", "Tqq", "Qaqq", "Qiqq", "Sxqq", "Spqq", "Ocqq", "Noqq", 
        "Sg", "Usg", "Dsg", "Tsg", "Qasg", "Qisg", "Sxsg", "Spsg", "Ocsg", "Nosg", 
        "St", "Ust", "Dst", "Tst", "Qast", "Qist", "Sxst", "Spst", "Ocst", "Nost", 
        "Og", "Uog", "Dog", "Tog", "Qaog", "Qiog", "Sxog", "Spog", "Ocog", "Noog", 
        "Ng", "Ung", "Dng", "Tng", "Qang", "Qing", "Sxng", "Spng", "Ocng", "Nong", 
        "Ce", "Uce"
    ];

    // DOM Elements
    const fileInput = document.getElementById('file-input');
    const toSettingsBtn = document.getElementById('to-settings-btn');
    const startBtn = document.getElementById('start-btn');
    const uploadScreen = document.getElementById('upload-screen');
    const settingsScreen = document.getElementById('settings-screen');
    const resultScreen = document.getElementById('result-screen');
    const fileNameDisplay = document.getElementById('file-name');
    const dispTitle = document.getElementById('disp-title');
    const tooltip = document.getElementById('tooltip');
    
    const changeFileBtn = document.getElementById('change-file-btn');
    const changeFileResBtn = document.getElementById('change-file-result-btn');
    const openSettingsBtn = document.getElementById('open-settings-btn');
    const restartBtn = document.getElementById('restart-btn');

    // Config Inputs
    const confTitle = document.getElementById('config-title');
    const confBottomTitle = document.getElementById('config-bottom-title');
    const confTotalLabel = document.getElementById('config-total-label');
    const confGapTarget = document.getElementById('config-gap-target');
    const dynamicGapTarget = document.getElementById('dynamic-gap-target');
    const confShowGapDetail = document.getElementById('config-show-gap-detail');
    const confResult = document.getElementById('config-result');
    const confBottom = document.getElementById('config-bottom-graph');
    const confBg = document.getElementById('config-bg-graph');
    const confTotal = document.getElementById('config-total');
    const confIcons = document.getElementById('config-icons');
    const confLineWidth = document.getElementById('config-line-width');
    
    const confDurSlider = document.getElementById('config-duration-slider');
    const confDurInput = document.getElementById('config-duration-input');
    const confHistSlider = document.getElementById('config-history-slider');
    const confHistInput = document.getElementById('config-history-input');

    const barsContainer = document.getElementById('bars-container');
    const axisContainer = document.getElementById('axis-container');
    const dateDisplay = document.getElementById('date-display');
    const combinedDisplay = document.getElementById('combined-display');
    const combinedGain = document.getElementById('combined-gain');
    const bottomGraphTitle = document.getElementById('bottom-graph-title');
    const statLabelEl = document.getElementById('stat-label-el');
    const combinedBox = document.getElementById('combined-box');
    const dailyGraphBox = document.getElementById('daily-graph-box');
    
    const bgCanvas = document.getElementById('bg-canvas');
    const dailyCanvas = document.getElementById('daily-canvas');
    const bgCtx = bgCanvas.getContext('2d');
    const dailyCtx = dailyCanvas.getContext('2d');

    const resCanvasTotal = document.getElementById('res-canvas-total');
    const resCanvasGain = document.getElementById('res-canvas-gain');
    const resCanvasGap = document.getElementById('res-canvas-gap');
    const replayBtn = document.getElementById('replay-btn');

    const seekSlider = document.getElementById('seek-slider');
    const seekVal = document.getElementById('seek-val');
    const speedSlider = document.getElementById('speed-slider');
    const speedDisplay = document.getElementById('speed-display');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const modeBtn = document.getElementById('mode-btn');

    // State
    let processedData = [];
    let itemsList = [];
    let colors = {};
    let itemImages = {};
    
    let isPlaying = false;
    let animationTime = 0;
    let lastFrameTime = 0;
    let playbackSpeed = 1;
    let barElements = {}; 
    let isGapMode = false;
    let animationFrameId = null;

    // Charts
    let chartTotal, chartGain, chartGap;

    // --- Utils ---
    function getContrastYIQ(hexcolor){
        if(!hexcolor) return 'black';
        hexcolor = hexcolor.replace("#", "");
        if(hexcolor.length === 3) hexcolor = hexcolor.split('').map(c=>c+c).join('');
        var r = parseInt(hexcolor.substr(0,2),16);
        var g = parseInt(hexcolor.substr(2,2),16);
        var b = parseInt(hexcolor.substr(4,2),16);
        var yiq = ((r*299)+(g*587)+(b*114))/1000;
        return (yiq >= 128) ? 'black' : 'white';
    }

    // --- File Handling ---
    function openFileSelector() {
        fileInput.value = null;
        fileInput.click();
    }

    changeFileBtn.addEventListener('click', openFileSelector);
    changeFileResBtn.addEventListener('click', openFileSelector);

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;
        
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        isPlaying = false;
        playPauseBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
        
        const reader = new FileReader();
        reader.onload = (ev) => {
            if(parseCSV(ev.target.result)) {
                if(uploadScreen.style.display !== 'none') {
                    fileNameDisplay.textContent = file.name;
                    toSettingsBtn.style.display = 'inline-flex';
                } else {
                    resultScreen.style.display = 'none';
                    settingsScreen.style.display = 'flex';
                    settingsScreen.style.opacity = 1;
                }
                updateGapTargetOptions();
            } else {
                alert("CSVエラー: フォーマットを確認してください。");
            }
        };
        reader.readAsText(file);
    });

    toSettingsBtn.addEventListener('click', () => {
        uploadScreen.style.opacity = 0;
        setTimeout(() => {
            uploadScreen.style.display = 'none';
            settingsScreen.style.display = 'flex';
        }, 300);
    });

    function updateGapTargetOptions() {
        const createOpts = (sel) => {
            sel.innerHTML = '<option value="Leader">1位 (自動)</option>';
            itemsList.forEach(item => {
                const opt = document.createElement('option');
                opt.value = item;
                opt.textContent = item;
                sel.appendChild(opt);
            });
        };
        createOpts(confGapTarget);
        createOpts(dynamicGapTarget);
        dynamicGapTarget.value = config.gapTarget;
    }

    confGapTarget.addEventListener('change', () => { config.gapTarget = confGapTarget.value; dynamicGapTarget.value = confGapTarget.value; });
    dynamicGapTarget.addEventListener('change', () => { config.gapTarget = dynamicGapTarget.value; confGapTarget.value = dynamicGapTarget.value; renderFrame(); });

    openSettingsBtn.addEventListener('click', () => {
        isPlaying = false;
        playPauseBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
        settingsScreen.style.display = 'flex';
        setTimeout(() => settingsScreen.style.opacity = 1, 10);
        if(itemsList.length > 0) {
            updateGapTargetOptions();
            confGapTarget.value = config.gapTarget;
        }
    });

    restartBtn.addEventListener('click', () => {
        animationTime = 0;
        isPlaying = true;
        playPauseBtn.innerHTML = '<i class="bi bi-pause-fill"></i>';
        lastFrameTime = performance.now();
        seekSlider.value = 0;
        seekVal.textContent = "0%";
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = requestAnimationFrame(gameLoop);
    });

    confDurSlider.addEventListener('input', () => { confDurInput.value = confDurSlider.value; });
    confDurInput.addEventListener('change', () => { 
        let val = parseInt(confDurInput.value); if(val < 1) val = 1;
        confDurInput.value = val; if(val >= 60 && val <= 600) confDurSlider.value = val;
    });

    confHistSlider.addEventListener('input', () => { confHistInput.value = confHistSlider.value; });
    confHistInput.addEventListener('change', () => {
        let val = parseInt(confHistInput.value); if(val < 1) val = 1;
        confHistInput.value = val; if(val <= 500) confHistSlider.value = val;
    });

    startBtn.addEventListener('click', () => {
        config.title = confTitle.value || "Subscriber Race";
        config.bottomTitle = confBottomTitle.value || "Daily Gain";
        config.totalLabel = confTotalLabel.value || "Combined Total";
        config.gapTarget = confGapTarget.value;
        config.showGapDetail = confShowGapDetail.checked;
        config.showResult = confResult.checked;
        config.showBottomGraph = confBottom.checked;
        config.showBgGraph = confBg.checked;
        config.showTotal = confTotal.checked;
        config.showIcons = confIcons.checked;
        config.graphLineWidth = parseInt(confLineWidth.value) || 4;

        dynamicGapTarget.value = config.gapTarget;
        
        const durVal = parseInt(confDurInput.value);
        if(durVal && durVal > 0) TOTAL_DURATION_BASE = durVal * 1000;
        const histVal = parseInt(confHistInput.value);
        if(histVal && histVal > 0) HISTORY_WINDOW = histVal;

        dispTitle.textContent = config.title;
        bottomGraphTitle.innerHTML = `<i class="bi bi-graph-up"></i> ${config.bottomTitle}`;
        statLabelEl.textContent = config.totalLabel;
        
        dailyGraphBox.style.visibility = config.showBottomGraph ? 'visible' : 'hidden';
        bgCanvas.style.display = config.showBgGraph ? 'block' : 'none';
        combinedBox.style.visibility = config.showTotal ? 'visible' : 'hidden';

        settingsScreen.style.opacity = 0;
        setTimeout(() => settingsScreen.style.display = 'none', 300);

        resizeAllCanvases();
        createDOMBars();
        
        animationTime = 0;
        seekSlider.value = 0;
        seekVal.textContent = "0%";
        
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        isPlaying = true;
        lastFrameTime = performance.now();
        playPauseBtn.innerHTML = '<i class="bi bi-pause-fill"></i>';
        animationFrameId = requestAnimationFrame(gameLoop);
    });

    function getSpeedFromSlider(val) {
        if(val <= 50) return 0.001 * Math.pow(1000, val/50);
        else return 1 * Math.pow(100, (val-50)/50);
    }

    speedSlider.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        playbackSpeed = getSpeedFromSlider(val);
        let label = playbackSpeed < 1 ? playbackSpeed.toFixed(2) : playbackSpeed.toFixed(1);
        if(playbackSpeed < 0.01) label = playbackSpeed.toFixed(4);
        speedDisplay.textContent = label + "x";
    });

    // --- Main Loop ---
    function gameLoop(now) {
        if(!isPlaying) return;
        const dt = now - lastFrameTime;
        lastFrameTime = now;

        animationTime += dt * playbackSpeed;
        if(animationTime >= TOTAL_DURATION_BASE) {
            animationTime = TOTAL_DURATION_BASE;
            isPlaying = false;
            playPauseBtn.innerHTML = '<i class="bi bi-arrow-counterclockwise"></i>';
            renderFrame(); 
            if(config.showResult) showResultScreen();
            return;
        }

        const pct = (animationTime / TOTAL_DURATION_BASE) * 100;
        seekSlider.value = pct;
        seekVal.textContent = Math.floor(pct) + "%";
        
        renderFrame();
        if(isPlaying) animationFrameId = requestAnimationFrame(gameLoop);
    }

    // --- Adaptive Text Scaling ---
    function updateAdaptiveText(element, value, type) {
        let str = "";
        let val = Math.floor(value);
        if(Math.abs(val) < 1e-9) val = 0;

        if (type === 'gain' || type === 'gap-diff') {
            str = (val >= 0 ? '+' : '') + val.toLocaleString();
        } else {
            str = val.toLocaleString();
        }
        element.textContent = str;
        const len = str.length;

        // More aggressive scaling logic for larger numbers
        if (type === 'main' || type === 'total') {
            if (len > 15) element.style.fontSize = '12px';
            else if (len > 13) element.style.fontSize = '14px';
            else if (len > 11) element.style.fontSize = '16px';
            else if (len > 9) element.style.fontSize = '20px';
            else element.style.fontSize = '26px';
        } else if (type === 'gain') {
             if (len > 12) element.style.fontSize = '9px';
             else if (len > 10) element.style.fontSize = '10px';
             else if (len > 8) element.style.fontSize = '12px';
             else element.style.fontSize = '16px';
        } else if (type === 'gap') {
             if (len > 12) element.style.fontSize = '10px';
             else if (len > 10) element.style.fontSize = '11px';
             else element.style.fontSize = '14px';
        } else if (type === 'gap-diff') {
             if (len > 12) element.style.fontSize = '9px';
             else if (len > 10) element.style.fontSize = '10px';
             else element.style.fontSize = '12px';
        }
    }

    // --- Render Frame ---
    function renderFrame() {
        const progress = animationTime / TOTAL_DURATION_BASE;
        const totalLen = processedData.length - 1;
        const currentFloatIdx = progress * totalLen;
        const idxLow = Math.floor(currentFloatIdx);
        const idxHigh = Math.min(idxLow + 1, totalLen);
        const ratio = currentFloatIdx - idxLow;

        const dLow = processedData[idxLow];
        const dHigh = processedData[idxHigh];

        let items = [];
        let totalVal = 0;
        let totalGain = 0;
        
        const getVal = (name) => lerp(dLow.values[name], dHigh.values[name], ratio);
        const getDiff = (name) => lerp(dLow.diffs[name], dHigh.diffs[name], ratio);

        itemsList.forEach(name => {
            const val = getVal(name);
            const diff = getDiff(name);
            items.push({ name, val, diff });
            totalVal += val;
            totalGain += diff;
        });

        items.sort((a,b) => b.val - a.val);
        const maxVal = items[0].val; 
        
        // Gap Target Logic
        let targetVal = 0;
        let targetDiff = 0;
        if (config.gapTarget === 'Leader') {
            targetVal = items[0].val;
            targetDiff = items[0].diff;
        } else {
            targetVal = getVal(config.gapTarget);
            targetDiff = getDiff(config.gapTarget);
        }

        // DOM Update
        items.forEach((item, rank) => {
            const el = barElements[item.name];
            el.row.style.transform = `translateY(${rank * 70}px)`;
            
            const barPct = (item.val / (maxVal * 1.25)) * 100;
            el.bar.style.width = barPct + '%';
            
            // Text Updates with Scaling
            updateAdaptiveText(el.mVal, item.val, 'main');
            updateAdaptiveText(el.sVal, item.diff, 'gain');
            el.sVal.className = 'val-diff' + (item.diff < 0 ? ' negative' : '');

            // Gap & Gap Gain
            if (config.showGapDetail) {
                let gap = targetVal - item.val;
                // Gap Gain calculation: 
                // Gap = Target - Self. 
                // NextGap = NextTarget - NextSelf.
                // GapDiff = NextGap - Gap = (NextTarget - Target) - (NextSelf - Self) = TargetDiff - SelfDiff
                let gapDiff = targetDiff - item.diff;

                if (Math.abs(gap) < 0.1) {
                    // It is the target
                    el.gVal.innerHTML = config.gapTarget==='Leader'?'Leader':'Target';
                    el.gVal.style.color = 'var(--color-green)';
                    el.gdVal.textContent = '';
                } else {
                    updateAdaptiveText(el.gVal, gap, 'gap');
                    el.gVal.style.color = '#ccc';
                    updateAdaptiveText(el.gdVal, gapDiff, 'gap-diff');
                    
                    // Color logic for Gap Diff: Positive means gap grew (bad for chaser), Negative means gap shrank (good)
                    // If gap is negative (ahead of target), logic flips, but standard race implies leader is ahead.
                    el.gdVal.className = 'val-gap-diff' + (gapDiff > 0 ? ' positive' : ' negative');
                }
                el.gRow.style.display = 'flex';
            } else {
                el.gRow.style.display = 'none';
            }

            // Labels
            const name = item.name;
            const contrastColor = getContrastYIQ(colors[name]);
            const labelWidth = name.length * 12 + 50; 
            const barWidthPx = (barsContainer.clientWidth * barPct) / 100;

            if(barWidthPx < labelWidth) {
                el.labelIn.textContent = "";
                el.labelOut.textContent = name;
                el.labelOut.style.display = "flex";
            } else {
                el.labelIn.textContent = name;
                el.labelIn.style.color = contrastColor;
                el.labelOut.style.display = "none";
            }

            // Gap Mode Visual (Bar Length)
            if(isGapMode) {
                // Gap mode: show bar as distance from leader? Or diff?
                // Visualizer usually keeps bars proportional to value. Gap is text.
                // If user wants "Gap Mode" bars, we recalculate width.
                // Assuming "Gap Mode" just changes text info in prev version, but now we have text always.
                // Let's make "Gap Mode" change the bottom graph to Gap History.
            }
        });

        // Global Stats
        renderAxisNice(maxVal * 1.25);
        const dObj = new Date(lerp(dLow.date.getTime(), dHigh.date.getTime(), ratio));
        dateDisplay.textContent = formatDate(dObj);
        
        updateAdaptiveText(combinedDisplay, totalVal, 'total');
        updateAdaptiveText(combinedGain, totalGain, 'gain');
        combinedGain.className = 'stat-gain' + (totalGain < 0 ? ' negative' : '');

        if(config.showBgGraph) {
            renderGraph({
                ctx: bgCtx, canvas: bgCanvas, data: processedData, items: itemsList,
                currentIdx: currentFloatIdx, windowSize: HISTORY_WINDOW,
                mode: 'Total', lineWidth: config.graphLineWidth, opacity: 0.6
            });
        }

        if(config.showBottomGraph) {
            renderGraph({
                ctx: dailyCtx, canvas: dailyCanvas, data: processedData, items: itemsList,
                currentIdx: currentFloatIdx, windowSize: HISTORY_WINDOW,
                mode: isGapMode ? 'Gap' : 'Diff', lineWidth: 3, opacity: 1.0,
                drawXAxis: true
            });
        }
    }

    // --- Dynamic Graph Renderer (Fixed Sync) ---
    function renderGraph({ctx, canvas, data, items, currentIdx, windowSize, mode, lineWidth, opacity, drawXAxis}) {
        const w = canvas.logicalWidth;
        const h = canvas.logicalHeight;
        ctx.clearRect(0, 0, w, h);
        ctx.globalAlpha = opacity;

        const totalLen = data.length;
        if(totalLen < 2) return;

        // Exact window for calculation
        const endIdx = Math.floor(currentIdx);
        const startIdx = Math.max(0, endIdx - windowSize);
        // Loop start allows drawing line from slightly before left edge
        const loopStart = Math.max(0, startIdx - 1); 
        
        // Gap Mode Logic (Leader tracking)
        let activeItems = items;
        if (mode === 'Gap' && config.gapTarget === 'Leader') {
            const row = data[endIdx]; 
            if(row) {
                let leaderVal = -Infinity;
                items.forEach(n => { if(row.values[n]>leaderVal) leaderVal = row.values[n]; });
                let chaserName = null; let chaserVal = -Infinity;
                items.forEach(n => {
                    if (row.values[n] < leaderVal && row.values[n] > chaserVal) {
                        chaserVal = row.values[n]; chaserName = n;
                    }
                });
                if (chaserName) activeItems = [chaserName];
            }
        }

        const getValue = (idx, name) => {
            idx = Math.max(0, Math.min(totalLen - 1, idx));
            const row = data[idx];
            if(mode === 'Total') return row.values[name];
            if(mode === 'Diff') return row.diffs[name];
            
            // Gap Calc
            let targetVal = 0;
            if (config.gapTarget === 'Leader') {
                let leader = -Infinity;
                for(let m=0; m<items.length; m++) if(row.values[items[m]]>leader) leader = row.values[items[m]];
                targetVal = leader;
            } else {
                targetVal = row.values[config.gapTarget];
            }
            return targetVal - row.values[name];
        };

        // --- PRECISE SCALE CALCULATION (NO LERP) ---
        // Calculate Min/Max exactly for the points that will be drawn in this frame.
        let localMin = Infinity;
        let localMax = -Infinity;

        // Check range [startIdx, endIdx + 1] to cover the interpolation
        const checkEnd = Math.min(totalLen - 1, endIdx + 1);

        for(let i = loopStart; i <= checkEnd; i++) {
            for(let k=0; k<activeItems.length; k++) {
                const name = activeItems[k];
                if (mode === 'Gap' && config.gapTarget !== 'Leader' && name === config.gapTarget) continue;
                const val = getValue(i, name);
                if (val < localMin) localMin = val;
                if (val > localMax) localMax = val;
            }
        }
        
        if(localMin === Infinity) localMin = 0;
        if(localMax === -Infinity) localMax = 10;
        
        let range = localMax - localMin || 10;
        // Padding
        const pMin = localMin - range * 0.1;
        const pMax = localMax + range * 0.1;
        const pRange = pMax - pMin || 1;

        // Layout
        const padT = 15;
        const padB = drawXAxis ? 30 : 15;
        const padL = 0;
        const padR = 10;
        const drawH = h - (padT + padB);
        const drawW = w - (padL + padR);

        // GRID (Synchronized)
        ctx.fillStyle = '#555';
        ctx.font = '10px Inter';
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.lineWidth = 1;

        // Draw Grid lines based on current pMin/pMax
        if(mode !== 'Total') {
            const roughStep = pRange / 5; 
            const gridMag = Math.pow(10, Math.floor(Math.log10(roughStep)));
            const norm = roughStep / gridMag;
            let niceStep = (norm<1.5)?1:(norm<3)?2:(norm<7)?5:10;
            const gridStep = niceStep * gridMag;

            const startTick = Math.ceil(pMin / gridStep) * gridStep;
            for(let v = startTick; v <= pMax; v += gridStep) {
                let displayV = v; if(Math.abs(displayV)<1e-9) displayV=0;
                const y = padT + drawH - ((displayV - pMin) / pRange) * drawH;
                if(y < padT || y > h - padB) continue; 
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
                ctx.fillText(formatNum(displayV), 5, y - 4);
            }
        }

        const windowStart = currentIdx - windowSize;
        const getX = (valIdx) => padL + (valIdx - windowStart) / windowSize * drawW;
        const getY = (val) => padT + drawH - ((val - pMin) / pRange) * drawH;

        // X-AXIS
        if(drawXAxis) {
            ctx.textAlign = 'center';
            const iStart = Math.ceil(windowStart);
            const iEnd = Math.floor(endIdx);
            for(let i = iStart; i <= iEnd; i++) {
                if(i < 0 || i >= totalLen) continue;
                const d = data[i].date;
                if(d.getDate() === 1) {
                    const x = getX(i);
                    ctx.beginPath(); ctx.moveTo(x, padT); ctx.lineTo(x, h - padB); 
                    ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.stroke();
                    ctx.fillStyle = '#888';
                    
                    // Format: 9-Dec-18
                    const dd = d.getDate();
                    const mNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
                    const mm = mNames[d.getMonth()];
                    const yy = String(d.getFullYear()).slice(-2);
                    
                    ctx.fillText(`${dd}-${mm}-${yy}`, x, h - 10);
                }
            }
            ctx.textAlign = 'left'; 
        }

        // LINES
        for(let k=0; k<activeItems.length; k++) {
            const name = activeItems[k];
            if (mode === 'Gap' && config.gapTarget !== 'Leader' && name === config.gapTarget) continue;

            ctx.beginPath();
            ctx.strokeStyle = colors[name];
            ctx.lineWidth = lineWidth;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            let lastX, lastY;
            let started = false;

            const processPoint = (i, isTip) => {
                let val;
                if(isTip) {
                    // Interpolate last segment
                    const idxLow = Math.floor(i);
                    const idxHigh = Math.min(totalLen - 1, idxLow + 1);
                    const r = i - idxLow;
                    val = lerp(getValue(idxLow, name), getValue(idxHigh, name), r);
                } else {
                    val = getValue(i, name);
                }

                const x = getX(i);
                const y = getY(val); // Uses precise pMin/pMax

                if(!started) {
                    ctx.moveTo(x, y);
                    started = true;
                } else {
                    const midX = (lastX + x) / 2;
                    const midY = (lastY + y) / 2;
                    ctx.quadraticCurveTo(lastX, lastY, midX, midY);
                }
                lastX = x; lastY = y;
            };

            for(let i = loopStart; i <= endIdx; i++) processPoint(i, false);
            // Draw up to exact float index
            processPoint(currentIdx, true);
            
            if(started) {
                ctx.lineTo(lastX, lastY);
                ctx.stroke();
                if(mode !== 'Total') {
                    ctx.fillStyle = colors[name];
                    ctx.beginPath(); ctx.arc(lastX, lastY, lineWidth*1.5, 0, Math.PI * 2); ctx.fill();
                }
            }
        }
    }

    // --- Result Chart ---
    class InteractiveChart {
        constructor(canvas, mode) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.mode = mode;
            this.dataPoints = [];
        }

        handleInteraction(x, y) {
            const rect = this.canvas.getBoundingClientRect();
            if(x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                const len = this.dataPoints.length;
                const ratio = (x - rect.left) / rect.width;
                const idx = Math.max(0, Math.min(len-1, Math.floor(ratio * (len-1))));
                this.draw(idx);
                this.showTooltipDOM(x - rect.left, y - rect.top, idx, rect);
                return true;
            }
            return false;
        }
        checkHover(cx, cy) { return this.handleInteraction(cx, cy); }
        clearHighlight() { this.draw(-1); }

        init(data, items) {
            this.dataPoints = [];
            let minVal = Infinity, maxVal = -Infinity;
            for(let i=0; i<data.length; i++) {
                const row = data[i];
                let rowObj = { date: row.date, values: {} };
                
                let targetVal = 0;
                if (config.gapTarget === 'Leader') {
                    let leader = -Infinity;
                    if(this.mode === 'Gap') items.forEach(n => { if(row.values[n]>leader) leader = row.values[n]; });
                    targetVal = leader;
                } else {
                    targetVal = row.values[config.gapTarget];
                }

                items.forEach(name => {
                    let v;
                    if(this.mode==='Total') v = row.values[name];
                    else if(this.mode==='Diff') v = row.diffs[name];
                    else v = targetVal - row.values[name];
                    
                    rowObj.values[name] = v;
                    
                    if (this.mode === 'Gap' && config.gapTarget !== 'Leader' && name === config.gapTarget) return;

                    if(v < minVal) minVal = v;
                    if(v > maxVal) maxVal = v;
                });
                this.dataPoints.push(rowObj);
            }
            let range = maxVal - minVal || 10;
            const buffer = range * 0.1;
            this.yMin = minVal - buffer; 
            this.yMax = maxVal + buffer;
            this.yRange = this.yMax - this.yMin;
            setupCanvas(this.canvas, this.ctx);
            this.draw();
        }

        showTooltipDOM(relX, relY, idx, rect) {
            const dp = this.dataPoints[idx];
            tooltip.style.display = 'block';
            const globalX = rect.left + relX;
            const globalY = rect.top + relY;
            let html = `<div class="tt-date">${formatDate(dp.date)}</div>`;
            let sorted = itemsList.map(n => ({n, v: dp.values[n]}))
                                  .sort((a,b) => (this.mode==='Gap' ? a.v - b.v : b.v - a.v)).slice(0, 8); 
            sorted.forEach(item => {
                let val = Math.floor(item.v); if(val===0) val=0;
                html += `<div class="tt-row"><span style="color:${colors[item.n]}">${item.n}</span><span class="tt-val">${val.toLocaleString()}</span></div>`;
            });
            tooltip.innerHTML = html;
            const ttRect = tooltip.getBoundingClientRect();
            const winW = window.innerWidth;
            let finalLeft = globalX + 15;
            if (finalLeft + ttRect.width > winW - 10) finalLeft = globalX - ttRect.width - 15;
            tooltip.style.left = finalLeft + 'px';
            tooltip.style.top = (globalY + 15) + 'px';
        }

        draw(hoverIdx = -1) {
            const w = this.canvas.logicalWidth;
            const h = this.canvas.logicalHeight;
            const ctx = this.ctx;
            const len = this.dataPoints.length;
            ctx.clearRect(0,0,w,h);
            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = 1;
            ctx.fillStyle = '#666';
            ctx.font = '10px Inter';

            const padding = 20; 
            const drawH = h - (padding * 2);
            const getY = (val) => padding + drawH - ((val - this.yMin) / this.yRange) * drawH;

            const step = this.yRange / 5;
            const startTick = Math.ceil(this.yMin / step) * step;
            for(let v = startTick; v <= this.yMax; v += step) {
                const y = getY(v);
                if(y < 5 || y > h - 5) continue;
                ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
                let displayV = v; if (Math.abs(displayV) < 1e-9) displayV = 0;
                ctx.fillText(formatNum(displayV), 5, y-4);
            }

            itemsList.forEach(name => {
                if (this.mode === 'Gap' && config.gapTarget !== 'Leader' && name === config.gapTarget) return;
                ctx.beginPath(); 
                ctx.strokeStyle = colors[name]; 
                ctx.lineWidth = 2;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                let lastX, lastY;
                let started = false;
                for(let i = 0; i < len; i++) {
                    const x = (i / (len-1)) * w;
                    const val = this.dataPoints[i].values[name];
                    const y = getY(val);
                    if(!started) { ctx.moveTo(x, y); started = true; } 
                    else {
                        const midX = (lastX + x) / 2;
                        const midY = (lastY + y) / 2;
                        ctx.quadraticCurveTo(lastX, lastY, midX, midY);
                    }
                    lastX = x; lastY = y;
                }
                if(started) ctx.lineTo(lastX, lastY);
                ctx.stroke();
            });

            if(hoverIdx >= 0) {
                const x = (hoverIdx / (len - 1)) * w;
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h);
                ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
            }
        }
    }

    // --- Screen Logic ---
    function showResultScreen() {
        resultScreen.style.display = 'flex';
        setTimeout(() => resultScreen.style.opacity = 1, 10);
        if(!chartTotal) {
            chartTotal = new InteractiveChart(resCanvasTotal, 'Total');
            chartGain = new InteractiveChart(resCanvasGain, 'Diff');
            chartGap = new InteractiveChart(resCanvasGap, 'Gap');
        }
        requestAnimationFrame(() => {
            setupCanvas(resCanvasTotal, resCanvasTotal.getContext('2d'));
            setupCanvas(resCanvasGain, resCanvasGain.getContext('2d'));
            setupCanvas(resCanvasGap, resCanvasGap.getContext('2d'));
            chartTotal.init(processedData, itemsList);
            chartGain.init(processedData, itemsList);
            chartGap.init(processedData, itemsList);
        });
    }

    function handleResultInteraction(clientX, clientY) {
        if(resultScreen.style.display === 'none') return;
        let anyHover = false;
        if(chartTotal && chartTotal.checkHover(clientX, clientY)) anyHover = true;
        if(chartGain && chartGain.checkHover(clientX, clientY)) anyHover = true;
        if(chartGap && chartGap.checkHover(clientX, clientY)) anyHover = true;
        if(!anyHover) tooltip.style.display = 'none';
    }

    window.addEventListener('mousemove', (e) => { handleResultInteraction(e.clientX, e.clientY); });
    window.addEventListener('touchstart', (e) => { if(e.touches.length > 0) handleResultInteraction(e.touches[0].clientX, e.touches[0].clientY); }, {passive: true});
    window.addEventListener('touchmove', (e) => { if(e.touches.length > 0) handleResultInteraction(e.touches[0].clientX, e.touches[0].clientY); }, {passive: true});

    replayBtn.addEventListener('click', () => {
        resultScreen.style.opacity = 0;
        setTimeout(() => resultScreen.style.display = 'none', 300);
        animationTime = 0;
        isPlaying = true;
        playPauseBtn.innerHTML = '<i class="bi bi-pause-fill"></i>';
        lastFrameTime = performance.now();
        seekSlider.value = 0;
        seekVal.textContent = "0%";
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = requestAnimationFrame(gameLoop);
    });

    // --- Helpers ---
    function setupCanvas(canvas, ctx) {
        if(!canvas.parentElement) return;
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        canvas.logicalWidth = rect.width;
        canvas.logicalHeight = rect.height;
    }

    function resizeAllCanvases() {
        setupCanvas(bgCanvas, bgCtx);
        setupCanvas(dailyCanvas, dailyCtx);
        if(chartTotal) { setupCanvas(resCanvasTotal, chartTotal.ctx); chartTotal.draw(-1); }
        if(chartGain) { setupCanvas(resCanvasGain, chartGain.ctx); chartGain.draw(-1); }
        if(chartGap) { setupCanvas(resCanvasGap, chartGap.ctx); chartGap.draw(-1); }
    }
    window.addEventListener('resize', resizeAllCanvases);

    function parseCSV(text) {
        try {
            const lines = text.trim().split(/\r\n|\n/);
            const headerParts = lines[0].split(',');
            const colorParts = lines[2].split(',');
            const clean = s => s ? s.replace(/^"|"$/g, '').trim() : '';
            itemsList = []; itemImages = {};
            for(let i=1; i<headerParts.length; i++) {
                const name = clean(headerParts[i]);
                if(name) { itemsList.push(name); colors[name] = clean(colorParts[i]) || '#fff'; }
            }
            let tempRaw = [];
            for(let i=3; i<lines.length; i++) {
                const parts = lines[i].split(',');
                const firstCol = clean(parts[0]);
                if(firstCol.toLowerCase() === 'image' || firstCol.toLowerCase() === 'icon') {
                    for(let k=1; k<parts.length; k++) if(k <= itemsList.length) itemImages[itemsList[k-1]] = clean(parts[k]);
                    continue;
                }
                const dateObj = new Date(firstCol);
                if(isNaN(dateObj.getTime())) continue;
                let row = { date: dateObj, values: {}, total: 0 };
                itemsList.forEach((name, idx) => {
                    const val = parseInt(clean(parts[idx+1])) || 0;
                    row.values[name] = val; row.total += val;
                });
                tempRaw.push(row);
            }
            processedData = tempRaw.map((curr, i) => {
                let diffs = {};
                itemsList.forEach(name => {
                    const prevVal = i > 0 ? tempRaw[i-1].values[name] : curr.values[name];
                    diffs[name] = curr.values[name] - prevVal;
                });
                return { ...curr, diffs };
            });
            return true;
        } catch(e) { return false; }
    }

    function createDOMBars() {
        barsContainer.innerHTML = ''; barElements = {};
        itemsList.forEach(name => {
            const row = document.createElement('div'); row.className = 'bar-row';
            const wrapper = document.createElement('div'); wrapper.className = 'bar-wrapper';
            const bar = document.createElement('div'); bar.className = 'bar'; bar.style.backgroundColor = colors[name];
            
            if(config.showIcons) {
                const img = document.createElement('img'); img.className = 'bar-img'; 
                if(itemImages[name]) { img.src = itemImages[name]; img.style.display='block'; }
                bar.appendChild(img);
            }
            
            const labelIn = document.createElement('div'); labelIn.className = 'bar-label-in';
            const labelOut = document.createElement('div'); labelOut.className = 'label-popout';
            
            // Value Container structure
            const vals = document.createElement('div'); vals.className = 'bar-values';
            
            // Row 1: Main Value + Diff
            const row1 = document.createElement('div'); row1.className = 'val-row-main';
            const mVal = document.createElement('div'); mVal.className = 'val-main';
            const sVal = document.createElement('div'); sVal.className = 'val-diff'; 
            row1.append(mVal, sVal);

            // Row 2: Gap Info
            const row2 = document.createElement('div'); row2.className = 'val-row-sub';
            const gLabel = document.createElement('span'); gLabel.className = 'val-gap-label'; gLabel.textContent = "Gap:";
            const gVal = document.createElement('div'); gVal.className = 'val-gap'; 
            const gdVal = document.createElement('div'); gdVal.className = 'val-gap-diff';
            row2.append(gLabel, gVal, gdVal);

            vals.append(row1, row2);
            bar.append(labelIn, vals); 
            wrapper.append(bar, labelOut); // labelOut is sibling to bar for overflow
            row.append(wrapper); barsContainer.append(row);
            
            barElements[name] = { row, bar, labelIn, labelOut, mVal, sVal, gRow: row2, gVal, gdVal };
        });
    }

    playPauseBtn.addEventListener('click', () => {
        if(animationTime >= TOTAL_DURATION_BASE && !isPlaying) animationTime = 0;
        isPlaying = !isPlaying;
        playPauseBtn.innerHTML = isPlaying ? '<i class="bi bi-pause-fill"></i>' : '<i class="bi bi-play-fill"></i>';
        if(isPlaying) { lastFrameTime = performance.now(); animationFrameId = requestAnimationFrame(gameLoop); }
    });

    seekSlider.addEventListener('input', (e) => {
        animationTime = (parseFloat(e.target.value) / 100) * TOTAL_DURATION_BASE;
        renderFrame();
    });

    modeBtn.addEventListener('click', () => {
        isGapMode = !isGapMode;
        modeBtn.innerHTML = isGapMode ? '<i class="bi bi-distribute-vertical"></i> Gapモード' : '<i class="bi bi-list-ol"></i> 通常モード';
        modeBtn.className = isGapMode ? 'icon-btn active' : 'icon-btn';
        bottomGraphTitle.innerHTML = isGapMode ? `<i class="bi bi-distribute-vertical"></i> 1位との差 (Gap)` : `<i class="bi bi-graph-up"></i> ${config.bottomTitle}`;
        renderFrame();
    });

    function lerp(a, b, t) { return a + (b - a) * t; }
    function formatDate(d) {
        // Nov 10, 2018 format
        const mNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        return `${mNames[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()}`;
    }
    
    function formatNum(n) {
        if (n === 0 || Math.abs(n) < 1e-9) return "0"; 
        let abs = Math.abs(n);
        let sign = n < 0 ? "-" : "";
        if (abs < 1000) return sign + Math.floor(abs).toLocaleString();
        const exp = Math.floor(Math.log10(abs) / 3);
        const suffixIndex = exp - 1;
        if (suffixIndex >= 0 && suffixIndex < SUFFIXES.length) {
            const scaled = abs / Math.pow(1000, exp);
            return sign + scaled.toFixed(1).replace('.0','') + SUFFIXES[suffixIndex];
        }
        return sign + Math.floor(abs).toLocaleString();
    }
    
    function renderAxisNice(maxVal) {
        axisContainer.innerHTML = '';
        const ticks = 5;
        const roughStep = maxVal / (ticks - 1);
        const mag = Math.pow(10, Math.floor(Math.log10(roughStep)));
        let niceStep = (roughStep/mag < 1.5) ? 1 : (roughStep/mag < 3) ? 2 : (roughStep/mag < 7) ? 5 : 10;
        const step = niceStep * mag;
        
        // Always include 0
        for(let v=0; v <= maxVal; v+=step) {
            const pct = (v/maxVal)*100;
            // Limit to 100% to avoid overflow
            if(pct > 100) break;
            
            const l = document.createElement('div'); l.className='grid-line'; l.style.left=pct+'%';
            const t = document.createElement('div'); t.className='axis-label'; t.textContent=formatNum(v); t.style.left=pct+'%';
            axisContainer.append(l, t);
        }
    }

</script>
</body>
</html>
